[{"id":0,"href":"/general/about/","title":"About","parent":"General","content":" About Uitsmijter is a versatile OAuth2 authorization server and a Kubernetes Middleware for Traefik.\nOn one side it provides a flexible and powerful basis for new projects, on the other hand it has been built with the focus to comfortably bring existing, mostly monolithic applications into the microservice, cloud- and multi-cloud world.\nIt offers multi-tenant single sign-on via secure, low-maintenance and easy-to-implement middleware, as well as protocol-compliant OAuth 2.0 authorization workflows. Both processes work hand in hand and, after minimal and easy-to-understand configuration in a short time after foolproof and fully automated (Infrastructure As Code) installation.\nA company-wide login can be put into operation within the shortest possible time in a vendor-neutral manner and without data specifications on your user profiles, even without changing the user database. It is important that your data contents and data structures as well as the data management can be determined by you at any time.\nUitsmijter does not bring its own user data storage, but offers interfaces to use your existing databases and services in a simple, secure and elegant way.\nRead more about our motivation for Uitsmijter\nUitsmijter is guided by original RFCs The original RFC for OAuth 2.0 endpoints is \u0026ldquo;The OAuth 2.0 Authorization Framework\u0026rdquo;, which was published as RFC 6749 in October 2012. This RFC defines the overall framework for OAuth 2.0, including the authorization process, the different grant types (such as authorization code and refresh token), and the roles of the various actors involved (such as the client, the resource owner, and the authorization server).\nIn addition to RFC 6749, there are several other RFCs that define specific aspects of the OAuth 2.0 framework. For example, RFC 6750 defines the Bearer Token usage, which specifies how to use access tokens in HTTP requests.\nAll information you need to install, configure, run the server, as well as configuring the client libraries are covered in this documentation. Our goal is to present you everything you need in an understandable language. If you are missing some aspects, please do not hesitate to contact us. We are improving the documentation constantly. Your feedback is welcome.\nFurther readings Terminology used in this documentation ","description":"About Uitsmijter is a versatile OAuth2 authorization server and a Kubernetes Middleware for Traefik.\nOn one side it provides a flexible and powerful basis for new projects, on the other hand it has been built with the focus to comfortably bring existing, mostly monolithic applications into the microservice, cloud- and multi-cloud world.\nIt offers multi-tenant single sign-on via secure, low-maintenance and easy-to-implement middleware, as well as protocol-compliant OAuth 2.0 authorization workflows."},{"id":1,"href":"/versions/ee/installation/","title":"Enterprise Edition Installation","parent":"Versions","content":" Helm Chart The Enterprise Edition can be easily installed via a Helm Chart.\nTo use the Helm Repository, you need a GitLab Access Token with read_api permissions and at least the Reporter role.\nYou can add the Uitsmijter Helm Repository by using the following commands:\nhelm repo add --username \u0026#39;[token name or gitlab user name]\u0026#39; --password \u0026#39;[gitlab access token]\u0026#39; uitsmijter https://git.ausdertechnik.de/api/v4/projects/528/packages/helm/stable helm repo update An overview of available configuration options can be found at Helm configuration.\nHelm Usage To install the newest version, run\nhelm upgrade --install uitsmijter uitsmijter/uitsmijter --namespace uitsmijter --create-namespace --devel A list of all available packages can be shown using\nhelm search repo uitsmijter --devel To show which version is currently installed:\nhelm list --namespace uitsmijter ","description":"Helm Chart The Enterprise Edition can be easily installed via a Helm Chart.\nTo use the Helm Repository, you need a GitLab Access Token with read_api permissions and at least the Reporter role.\nYou can add the Uitsmijter Helm Repository by using the following commands:\nhelm repo add --username \u0026#39;[token name or gitlab user name]\u0026#39; --password \u0026#39;[gitlab access token]\u0026#39; uitsmijter https://git.ausdertechnik.de/api/v4/projects/528/packages/helm/stable helm repo update An overview of available configuration options can be found at Helm configuration."},{"id":2,"href":"/general/","title":"General","parent":"Uitsmijter Documentation","content":" General About Terminology Motivation Requirements Quick Start Guide ","description":" General About Terminology Motivation Requirements Quick Start Guide "},{"id":3,"href":"/providers/providers/","title":"General provider information","parent":"Providers","content":" General provider information Because Uitsmijter does not store any user data to authenticate a login, request providers are written to check if given credentials are valid. Each tenant has a set of providers to do certain tasks. The User Login Provider is responsible for the user backend which knows how to verify user credentials. The User Validation Provider is responsible to check if a username still exists in the backend user store.\nThe design of the authorization server is built to work with different - especially already existing - backends. It is one of the goals to easily be attachable to existing projects. Replacing an old in-app login form with an SSO should be very simple and straight forward. Tasks like user migration is not necessary as user data stays in its existing location. Changing user backends means changing the provider code and not migrating user data.\nLanguage Provides are written in ECMA-Script (better known as JavaScript). The runtime is based upon Webkit and has a few additional convenience functions:\nFunction Description console.log Logs to the info level console.error Logs to the error level say A shorthand for console.log fetch Method to fetch an external resource commit Commit the provider\u0026rsquo;s result and hand back to the process md5 Hashes a string into a md5 checksum sha256 Hashes a string into a sha256 checksum Provider classes to implement Each tenant has to implement a User Login Provider code snippet and a User Validation Provider (both are called: provider)\nMinimal example:\nproviders: - class UserLoginProvider { constructor(credentials) { commit(true); } get canLogin() { return true; } get userProfile() { return {message:\u0026#34;DO NOT USE THIS IN PRODUCTION\u0026#34;}; } get role() { return \u0026#34;development\u0026#34;; } } - class UserValidationProvider { constructor(args) { commit(true); } get isValid() { return true } } The providers are responsible for verifying the user and getting the profile of a user into the authorization server. Providers are only glue code and normally should not implement any business logic at all. Usually, providers are sending a request to some service and committing the result back.\nExample:\nproviders: - | class UserLoginProvider { isLoggedIn = false; profile = {}; role = null; constructor(credentials) { fetch(`http://checkcredentials.checkcredentials.svc.cluster.local/validate-login`, { method: \u0026#34;post\u0026#34;, body: { username: credentials.username, passwordHash: sha256(credentials.password) } }).then((result) =\u0026gt; { var subject = {}; profile = JSON.parse(result.body); if (result.code == 200) { this.isLoggedIn = true; this.role = profile.role; subject = {subject: profile.userId}; } commit(result.code, subject); }); } get canLogin() { return this.isLoggedIn; } get userProfile() { return this.profile; } get role() { return this.role; } } - | class UserValidationProvider { isValid = false; constructor(args) { fetch(`http://checkcredentials.usertrunk.svc.cluster.local/validate-user`, { method: \u0026#34;post\u0026#34;, body: { username: args.username, } }).then((result) =\u0026gt; { response = JSON.parse(result.body); if (result.code == 200 \u0026amp;\u0026amp; response.isDeleted === false) { this.isValid = true; } commit(this.isValid); }); } get isValid() { return this.isValid; } } For the UserLoginProvider you have to commit the results within the constructor method. You also have to provide the three getters:\ncanLogin userProfile role For the UserValidationProvider you have to commit a status within the constructor method that indicates that your operation is done. You also have to provide one getter:\nisValid The execution time of a provider is limited. The advanced setting SCRIPT_TIMEOUT can manipulate that behaviour in the future, but the default (and this is what you should use, if not less) is set to 30 seconds. The provider has to complete all tasks within this time limit, this includes performing all necessary requests and reply with the result.\nFurther readings User Login Provider User Validation Provider ","description":"General provider information Because Uitsmijter does not store any user data to authenticate a login, request providers are written to check if given credentials are valid. Each tenant has a set of providers to do certain tasks. The User Login Provider is responsible for the user backend which knows how to verify user credentials. The User Validation Provider is responsible to check if a username still exists in the backend user store."},{"id":4,"href":"/configuration/helm/","title":"Helm configuration","parent":"Configuration","content":" Helm configuration parameters Uitsmijter is best to install over helm.\nhelm repo add uitsmijter https://charts.uitsmijter.io/ helm update To list available versions run:\nhelm search repo uitsmijter To see a list with release candidates included:\nhelm search repo uitsmijter --devel The complete Values.yaml is presented first, than the parameters are described as on overview. For detailed information please read the quick start guide.\nFull Values.yaml namespaceOverride: \u0026#34;\u0026#34; image: repository: ghcr.io/uitsmijter/uitsmijter # Overrides the image tag whose default is the chart appVersion. tag: \u0026#34;\u0026#34; pullPolicy: Always imagePullSecrets: - name: gitlab-auth jwtSecret: \u0026#34;vosai0za6iex8AelahGemaeBooph6pah6Saezae0oojahfa7Re6leibeeshiu8ie\u0026#34; redisPassword: \u0026#34;Shohmaz1\u0026#34; storageClassName: \u0026#34;default-ext4\u0026#34; installCRD: true installSA: true config: # Log format options: console|ndjson logFormat: \u0026#34;console\u0026#34; # Log level options: trace|info|error|critical logLevel: \u0026#34;info\u0026#34; cookieExpirationInDays: 7 tokenExpirationInHours: 2 tokenRefreshExpirationInHours: 720 # show the version information at /versions displayVersion: true crd: enabled: true scoped: false domains: - domain: \u0026#34;nightly.example.com\u0026#34; tlsSecretName: \u0026#34;example.com\u0026#34; - domain: \u0026#34;nightly2.example.com\u0026#34; tlsSecretName: \u0026#34;example.com\u0026#34; Parameter description Parameter Default Description namespaceOverride uitsmijter Namespace to install Uitsmijter to. image.repository Docker repository for the Uitsmijter server image. image.tag Version-Tag to install. Must be present in the image.repository. image.pullPolicy Always The pull policy of the used image. imagePullSecrets.name When using a private repository, the name of the dockerPullSecret. See 🔗 Pull an Image from a Private Registry jwtSecret Passphrase with that each JWT-token is signed. redisPassword Password for the 🔗 Redis database where all refresh tokens are stored. storageClassName Kubernetes 🔗 Storage Class to use to store the redis data. installCRD true Install necessary 🔗 Custom Resource Definitions for Tenants and Clients. installSA true Install 🔗 Service Accounts to allow to read Tenants and Clients. config.logFormat console Log format options: console or ndjson. config.logLevel info Level of log verbosity. Options: trace, info, error or critical config.cookieExpirationInDays 7 Days a cookie is valid without refreshing its value. config.tokenExpirationInHours 2 Invalidates the JWT-Token after number of hours. config.tokenRefreshExpirationInHours 720 Invalidates the refresh token after number of hours. config.displayVersion true Displays the version information of Uitsmijter under /versions publicly for all. You can turn this off for security reasons. config.crd.enabled true Enables supoprt for loading Custom Resource Definitions of Tenants and Clients, should be true for Kubernetes installations. config.crd.scoped false Restrict Uitsmijter Custom Resource Definitions loader to load only tenants and clients from the namespace in which Uitsmijter itself is installed. domains.domain List of Domains. Entry of the domain where Uitsmijter is listening on. domains.tlsSecretName List of Domains. Entry of the name of the certificate secret. Install Uitsmijter Helm Charts helm install uitsmijter -f values.yaml uitsmijter/uitsmijter Overwrite Parameters in a CI/CD-Pipeline from source Overwriting parameters from the command line is possible. For example install Uitsmijter in a feature branch, it is not handy to provide extra Values.yaml\u0026rsquo;s, but set the parameters at the shell directly.\nHere is an example from our gitlab pipeline to install feature-branches in its own namespace:\n- helm upgrade --install uitsmijter ./Deployment/helm/uitsmijter --set image.tag=${CONTAINER_IMAGE_TAG} --set \u0026#34;domains[0].domain=${CI_COMMIT_REF_SLUG}.example.com\u0026#34; --set \u0026#34;domains[0].tlsSecretName=example.com\u0026#34; --set \u0026#34;installCRD=false\u0026#34; --set \u0026#34;config.logLevel=debug\u0026#34; --namespace \u0026#34;uitsmijter-${CI_COMMIT_REF_SLUG}\u0026#34; You can overwrite every parameter from the parameter description.\n","description":"Helm configuration parameters Uitsmijter is best to install over helm.\nhelm repo add uitsmijter https://charts.uitsmijter.io/ helm update To list available versions run:\nhelm search repo uitsmijter To see a list with release candidates included:\nhelm search repo uitsmijter --devel The complete Values.yaml is presented first, than the parameters are described as on overview. For detailed information please read the quick start guide.\nFull Values.yaml namespaceOverride: \u0026#34;\u0026#34; image: repository: ghcr.io/uitsmijter/uitsmijter # Overrides the image tag whose default is the chart appVersion."},{"id":5,"href":"/customisation/template_login/","title":"Login Page","parent":"Customisation","content":" Login- and Logout-Page Customisation There are multiple ways to customize the login and logout pages.\nThe easiest way is to configure additioanl tenant informations like imprint, privacy policy and registration URLs.\nIn addition to that it is also possible to change page templates because every tenant can have their own login page.\nLoading templates from template directory In the source code version of Uitsmijter you can to create a folder that is named after the slug of the tenant name.\nOpen the folder Resources / Views and create a new folder. Assuming the tenant is called example, from the project root create a folder for the templates:\nmkdir Resources/Views/example and copy the default templates in that folder:\ncp -r Resources/Views/default/* Resources/Views/example Now you can edit the file Resources/Views/example/login.leaf to build your own customized login page. The correct template will be selected automatically by the tenant requesting the login.\nUitsmijter uses Leaf templates to render pages.\nLoading templates from S3 bucket When Uitsmijter is deployed via kubernetes it is easier to load the templates from an external source. For that case Uitsmijter supports loading tempalte files from a S3 compatible storage provider.\nYou can configure the S3 access as templates int your tenant.yaml, as described in the Tenant configuration. The template files will be loaded to Uitsmijter when the tenant is read. You can view the expected directory structure and file names in Resources/Views/default, not all files must be provided.\nSettings On Error If an error occurred, then the error variable is set with the error_token.\nHint: You may want to set extra classes on error. You can use the helper isnotempty(:var, :print) to print out some text when :var is empty. eg:\n\u0026lt;div class=\u0026#39;login-box #isnotempty(error, \u0026#34;error\u0026#34;)\u0026#39;\u0026gt; _If `error? is not empty, say: \u0026ldquo;error\u0026rdquo;\nTo render the error you have to translate it into the user requested language:\n#if(error != nil): \u0026lt;div class=\u0026#34;error\u0026#34;\u0026gt;#t(error)\u0026lt;/div\u0026gt; #endif Translation To translate a token use #t(:token).\nYou may want to provide your own sentences for the errors. You can do a big if-else chain for each of the error messages:\n#if(error == \u0026#34;LOGIN.ERRORS.FORM_NOT_PARSEABLE\u0026#34;): \u0026lt;div\u0026gt;...\u0026lt;/div\u0026gt; #elseif(error == \u0026#34;LOGIN.ERRORS.CONSTRUCT_DATE_ERROR\u0026#34;): \u0026lt;div\u0026gt;...\u0026lt;/div\u0026gt; #elseif(error == \u0026#34;LOGIN.ERRORS.MISSING_LOCATION\u0026#34;): \u0026lt;div\u0026gt;...\u0026lt;/div\u0026gt; #elseif(error == \u0026#34;LOGIN.ERRORS.NO_TENANT\u0026#34;): \u0026lt;div\u0026gt;...\u0026lt;/div\u0026gt; #elseif(error == \u0026#34;LOGIN.ERRORS.WRONG_CREDENTIALS\u0026#34;): \u0026lt;div\u0026gt;...\u0026lt;/div\u0026gt; Login Form The form action have to point to #(serviceUrl)/login and the following form fields must be provided:\nfield value location #(requestUri) username password ","description":"Login- and Logout-Page Customisation There are multiple ways to customize the login and logout pages.\nThe easiest way is to configure additioanl tenant informations like imprint, privacy policy and registration URLs.\nIn addition to that it is also possible to change page templates because every tenant can have their own login page.\nLoading templates from template directory In the source code version of Uitsmijter you can to create a folder that is named after the slug of the tenant name."},{"id":6,"href":"/oauth/flow/","title":"OAuth flow","parent":"OAuth","content":" OAuth flow OAuth 2.0 is an open standard for authorization that enables third-party applications to obtain limited access to a user\u0026rsquo;s resources without requiring the user to provide their login credentials.\nThere are several flows that can be used with OAuth 2.0, depending on the type of application and the resources it needs to access. Here is a brief overview of the most common flows that ist supported by Uitsmijter:\nAuthorization code flow: This flow is used by web applications that need to access resources on behalf of a user. The flow consists of the following steps: The user is redirected to the authorization server, where they are asked to grant the application access to their resources. If the user grants access, the authorization server returns an authorization code to the application. The application exchanges the authorization code for an access token and a refresh token. The application can use the access token to make API requests on behalf of the user. If the access token expires, the application can use the refresh token to obtain a new one. Uitsmijter supports authorization code flow with PKCE extension that is suited to use for single-page-applications as well.\nImplicit flow: This flow is similar to the authorization code flow, but it is deprecated. The flow consists of the following steps: The user is redirected to the authorization server, where they are asked to grant the application access to their resources. If the user grants access, the authorization server returns an access token to the application. The application can use the access token to make API requests on behalf of the user. There is no refresh token in this flow, so the access token must be used immediately and cannot be refreshed. Uitsmijter supports the implicit flow when it is explicit turned on only! this flow should be treated as deprecated.\nImplicit flow can be turned on in the client grant_type config:\ngrant_types: - password See tenant and client config for more details.\nRefresh token flow is a way to obtain a new access token using a refresh token, which is a token that is issued along with the access token and can be used to obtain a new access token when the original one expires. Here is an overview of the refresh token flow: The application uses the access token to make API requests on behalf of the user. When the access token expires, the application sends a request to the authorization server to exchange the refresh token for a new access token. The authorization server returns a new access token to the application. The application can use the new access token to make API requests on behalf of the user. The refresh token flow is typically used in conjunction with the authorization code flow. It allows the application to obtain a new access token without requiring the user to grant access again. This is useful in cases where the user has granted the application long-term access to their resources, and the application needs to be able to access those resources continuously without requiring the user to re-authorize it.\nGeneral schematic of the authorization code flow Backend-For-Frontend A backend for frontend (BFF) is a layer in an application architecture that sits between the frontend (client-side) and the backend (server-side). The purpose of a BFF is to provide a specific set of APIs that are tailored to the needs of the frontend, rather than exposing the full set of APIs from the backend.\nIn general, a BFF is useful when the frontend and backend of an application are developed and maintained by separate teams, or when the frontend needs to access multiple backend services in a specific way. It provides a way to decouple the frontend and backend and make it easier to manage the interactions between them.\nImplementing a OAuth flow into a BFF-style application works like this schematic show:\nFirst the good part: you do not have to implement all the request response cycle by your own, there are several libraries that handle all of this for you. However, we recommend that you understand the process in order to be able to resolve any problems in your implementation.\nA typical OAuth flow for logins for a BFF:\nThe user makes the first request in a Browser to the backend server (1). When the user is unauthenticated the backend server returns a redirect response (2) that the browser will follow to request an authorisation code (3). The authorisation server prompts a login form, validated the credentials (4) and return a code response (5) within a callback information. The Browser than takes the code and sends it to the backend server (6). The backend server takes that code for an exchange (7). The authorisation server validates the code and if PKCE is active validates the proof key, too (8). If everything is correct, the authorisation server responds the token (9). Only the backend server have knowledge of the code and the frontend seen the code only! The backend server can talk to the resource server with the valid token attached (10) for initial requests and for exchanging resources (11). The Browser gets responses from the backend server only that have to keep the token for the user secure.\nThe BFF should send the token in an authorisation header to the resource server. The browser should never see the token in a request response cycle.\nSingle Page Application and mobile apps A single-page application (SPA) is a type of web application that loads a single HTML page and dynamically updates the page as the user interacts with the application.\nIn a traditional web application, the user clicks on a link or submits a form, and the server responds by sending a new HTML page to the client. In an SPA, the user interacts with the application, and the application sends requests to the server to retrieve data or perform actions. The server responds with data, rather than a new HTML page, and the application updates the page dynamically to reflect the new data.\nSPAs are designed to provide a more responsive and interactive user experience, as they do not require the page to be reloaded each time the user performs an action. They can also reduce the amount of data transmitted between the client and server, as the server only needs to send data, rather than a full HTML page, for each request.\nThe architectural design of an SPA is similar to that of a mobile app in that both types of applications are designed to run client-side and provide a responsive, fluid user experience. In an SPA, the entire application is loaded onto the client device, and subsequent interactions with the application are handled through JavaScript and APIs, without the need to reload the page. This allows the application to respond to user actions quickly and seamlessly, much like a native mobile app.\nThe authorization code flow is a bit different to that described in Backend-For-Frontend, because there is no backend involved that keeps track of the user session.\nAttention:\nThe authorization code flow with PKCE (Proof Key for Code Exchange) extensions should be used when implementing authentication in single-page applications (SPAs) and mobile apps. PKCE is an additional security measure that helps to protect against certain types of attacks, such as code injection or man-in-the-middle attacks, by using a secret key that is verified at the time of the authorization request and again when the authorization code is exchanged for an access token. By using the authorization code flow with PKCE extensions, you can ensure that your SPA or mobile app is secure and that user data is protected.\nImplementing a OAuth flow into a BFF-style application works like this schematic show:\nAgain the good part: you do not have to implement all the request response cycle by your own, there are several libraries that handle all of this for you. Nevertheless, we recommend understanding the process to better troubleshoot potential implementation errors.\nA typical OAuth flow for logins for a SPAs and mobile apps: The browser or app (user) explicit request a login (1) at the authorisation server. The authorisation server send a redirect link to the login page (2) back to the user. The users browser follows the redirect (3) to request an authorisation code. If the user is not logged in the authorisation server prompt a login page (4) and validates the credentials. If those are correct the authorisation server responds with a code (5). The browser/app takes that code and request and access code (6). be sure that a pkce challenge is send and the client have enabled the PKCE-only flag. Next, the authorisation server validates the code and the pkce challenge and verifier (7) and respond with a valid token (8) back to the browser/app. In every request from the user to the resource server (9) the token is set in the authorisation header and the resource server can respond the requested resource (10) for valid users only by validating the JWTs.\nEvery aspect of this flow is covered in well known and good tested libraries. The demo application uses oidc-client-ts for example to do all the steps in the flow secure in the background.\nFurther readings Available Grant types with examples ","description":"OAuth flow OAuth 2.0 is an open standard for authorization that enables third-party applications to obtain limited access to a user\u0026rsquo;s resources without requiring the user to provide their login credentials.\nThere are several flows that can be used with OAuth 2.0, depending on the type of application and the resources it needs to access. Here is a brief overview of the most common flows that ist supported by Uitsmijter:"},{"id":7,"href":"/contribution/development/","title":"Project information","parent":"Contribution","content":" Project information This project is written in Swift. Started in Swift version 5.7 and moved on to Swift 5.9. It\u0026rsquo;s done with grate support from the Vapor framework and the Swift Server Workgroup community.\nPlease check out the server side swift conference if you are interested.\nUitsmijter chooses swift, because of:\nsafety Strongly Typed encourages to write clean and consistent code safeguards Well-designed asynchronous programming interface performance Small footprint Quick startup time Deterministic performance software design patterns Code structure Swift\u0026rsquo;s history and also Vapor\u0026rsquo;s boilerplate\u0026rsquo;s sort code into folders according to their technical role. For example: all controllers, like login-routes, metrics-routes, etc. are stored in the Controllers folder. All models are stored in Models etc. Often, you see projects with all extensions in a Extensions folder, etc\u0026hellip;.\nAs much as we stick to common sense and best practices, we break this rule for multiple reasons:\nThe type is already included in the filename, and if not, the type will reflect that. A struct user is always a User model and will never be a /users route, which would be called UsersController. The understandability of the application parts as a concept is more important than a known comfort zone when the application is first opened. This is especially true when an application has a strong impact on the security of third-party applications. Targeting function blocks, tracking changes, and checking closed folders is more comfortable than jumping around the entire application. Initially, I (the first developer) tried to fit the code for this project into exactly this known ordering structure, but I soon found it difficult to get an overview of what a business function needs and how the business units are separated from each other and how to link them together in a way that any new developer would understand it directly. Halfway through, I switched to a domain driven design and organized the source files according to their functionality.\nThis means:\nControllers are distributed everywhere There is a Login folder, where all controllers, models, extensions, which are necessary and hardly bound to the login function, right next to a ScriptingProvider folder that contain all the source code for the provider javascript scripting functionality. Nevertheless, a Monitor folder contains all the controllers, models, etc. that need the /health and /metrics routes to operate. The disadvantages:\nWe will have some leftovers that do not fit in one area. Common code is between two functions and should be in both. There will be mixed directories, that do not describe a clear domain. For example there is a Entities directory, that does exactly what a Models folder should do, but we keep it clear from other models than pure entities that are acting inside the system and are interchanging between the domains.\nWe are trying to minimize the downsides and hope that the brake on the rules will help maintaining a safe system.\nGetting it to work For development, the Uitsmijter source provides a toolchain to build, lint, test and run the Project locally inside a Docker container. See tooling for a detailed description.\nIf you do not like to work inside docker, Uitsmijter should run on every system that supports the Swift language, including Mac, Linux and Windows. List of supported platforms.\nBefore editing, be sure that it builds correctly:\nCheck out the packages: swift package resolve Running tests: swift test Build the binary: swift build run Uitsmijter locally: swift run We highly recommend to use the toolchain and build Uitsmijter inside the container.\nIDE Of course you can use the IDE of your choice. For a super quick start, Uitsmijter offers an IDE in the browser. The command ./tooling.sh code starts an IDE in a Docker container, which makes it easier to get started with the code.\nFurther readings Using the toolchain for development at Uitsmijter. Guidelines for development. Alternatives to Uitsmijter for development. ","description":"Project information This project is written in Swift. Started in Swift version 5.7 and moved on to Swift 5.9. It\u0026rsquo;s done with grate support from the Vapor framework and the Swift Server Workgroup community.\nPlease check out the server side swift conference if you are interested.\nUitsmijter chooses swift, because of:\nsafety Strongly Typed encourages to write clean and consistent code safeguards Well-designed asynchronous programming interface performance Small footprint Quick startup time Deterministic performance software design patterns Code structure Swift\u0026rsquo;s history and also Vapor\u0026rsquo;s boilerplate\u0026rsquo;s sort code into folders according to their technical role."},{"id":8,"href":"/interceptor/quickstart/","title":"Walkthrough guide","parent":"Interceptor","content":" Walkthrough guide for securing static webserver resources The Project Setup In the quick start guide chapter we have designed a new application with two portals, four services and one user store. The quick start guide shows how to set up Uitsmijter as a multi-tenant, multi-client authorisation server.\nFor this additional walkthrough documentation we assume that a last-minute change request for the business hits the development team. The requirement is, that the company\u0026rsquo;s Design-Cookbook should be accessible for all partners. The Design-Cookbook is a bunch of existing html files sitting in a NGINX on the clusters\u0026rsquo; namespace \u0026ldquo;cookbooks\u0026rdquo;.\nRead the general quickstart first You have to read the quick start guide first. Many of the examples on this page refers to the examples at the quickstart chapter.\nConsider using a OAuth-Flow for new projects. It is far more elegant and gives you more possibilities for your setup. Yes, the initial amount of work to implement an oauth client is a bit higher (you have to understand the client libraries to use), but the fine granular options will help your project to grow later.\nNevertheless, the interceptor mode offers a number of advantages that allow you to implement two scenarios on very short time:\nProtecting static web servers and resources (spoiler: it is a one-liner to your ingress definition) Migrating monolith projects with an own user store to a kubernetes service without rewriting the entire application logic first. (You may want to start with Interceptor Mode first, run it in parallel and then migrating step by step to oauth. We discuss this scenario in detail in the migrating monolith section.) Scenario We assume that the cookbook has already been packed into an NGINX container and successfully deployed to the cluster. Maybe it is open to the world or currently behind a basic auth. We need to secure this site with Uitsmijter and only let partners to access the pages.\nHow to achieve the requirements The scenario is brilliant to demonstrate why Uitsmijter is the best choose for new projects. It is easy to attach new requirements to the system within minutes.\nBecause the NGINX does not have any frontend application, like an SPA or an BFF we can not implement a known OAuth-Flow. Because the users are stored in a private service, we can not easily attach some nginx authentication to it (Well, only with lots of custom code, a bunch of lua scripts, a non default docker image, ect\u0026hellip;). Here fits the Interceptor-Mode extremely well, because it allows you to first attach an authorisation header to every request, and second protect every resource with a secure login page if the authorisation header is missing or invalid.\nAs Uitsmijter uses the same internal login mechanism for the Interceptor-Mode than for the OAuth-Login, the same backend providers can be used.\nTenants and Clients Under other circumstances we would switch on the tenants configuration flag interceptor.enabled and we are done! But the requirements said, that only \u0026ldquo;partners\u0026rdquo; should have access to the cookbook. A UserLoginProvider (see User Login Provider) do have one script for all logins only and does not have any access to the login method of a user.\nIt is important to understand the concept of tenants and their clients ( see tenant and client configuration for more details). Remember that BackendProviders are defined at tenant level.\nIn the example of this demo project, we have to use the same user store but have to react on the \u0026ldquo;role\u0026rdquo; of the user. The nature of a Interceptor-Mode is a boolean state: allowed to access, or denied to access a resource. Unlike an OAuth application that may react on roles and scopes, a resource behind an interceptor protected ingress can be accessed when the user is logged in, regardless of the role. Scopes are not implemented in Interceptor-Mode, because the resource covered behind the login can not interpret this information. Disclaimer: a monolith application (e.g. an php server) could - and should - extract this information from the authorisation header, but static webservers with plain html files can\u0026rsquo;t.\nEven the cookbook service is for the same \u0026ldquo;Company\u0026rdquo;, the best way to fulfill the requirements is to add a new tenant.\nRemember: The Interceptor-Mode ist tenant based, not client based! Luckily the providers are, too.\nAdd this new tenant to the cookbooks namespace:\n--- apiVersion: \u0026#34;uitsmijter.io/v1\u0026#34; kind: Tenant metadata: name: cookbook spec: hosts: - cookbooks.example.com interceptor: enabled: true domain: login.example.com cookie: .example.com providers: - | class UserLoginProvider { isLoggedIn = false; profile = {}; role = null; constructor(credentials) { fetch(`http://checkcredentials.checkcredentials.svc.cluster.local/validate-login`, { method: \u0026#34;post\u0026#34;, body: { username: credentials.username, passwordHash: sha256(credentials.password) } }).then((result) =\u0026gt; { var subject = {}; profile = JSON.parse(result.body); if (result.code === 200 \u0026amp;\u0026amp; profile.role.indexOf(\u0026#39;partner\u0026#39;) \u0026gt; -1) { this.isLoggedIn = true; this.role = profile.role; subject = {subject: profile.userId}; } commit(result.code, subject); }); } get canLogin() { return this.isLoggedIn; } get userProfile() { return this.profile; } get role() { return this.role; } } - | class UserValidationProvider { isValid = false; constructor(args) { fetch(`http://checkcredentials.checkcredentials.svc.cluster.local/validate-user`, { method: \u0026#34;post\u0026#34;, body: { username: args.username } }).then((result) =\u0026gt; { response = JSON.parse(result.body); if (result.code === 200 \u0026amp;\u0026amp; response.isDeleted === false) { this.isValid = true; } commit(this.isValid); }); } get isValid() { return this.isValid; } } Two changes are made. First interceptor.enabled is set to true. This allows a request to pass the middleware if the label is set to the ingress. Secondly, we only allow users with a partner role to get access on this tenant. That is made by a change in the provider script: profile.role.indexOf('partner') \u0026gt; -1.\nSave the file as cookbook-tenant.yaml and apply it to the cookbooks namespace:\nkubectl apply -n cookbooks -f cookbook-tenant.yaml Because the Interceptor-Mode enabler and the UserLoginProvider is set at tenant level, we do not need to declare a client.\nIngress Since the interceptor is marked with enabled: true, we only have to connect the ingress with Uitsmijter. Open the ingress file for the cookbook service and add one line.\napiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: design-cookbook annotations: traefik.ingress.kubernetes.io/router.entrypoints: websecure traefik.ingress.kubernetes.io/router.tls: \u0026#34;true\u0026#34; traefik.ingress.kubernetes.io/router.middlewares: uitsmijter-forward-auth@kubernetescrd spec: tls: - secretName: example.com rules: - host: cookbooks.example.com http: paths: - path: \u0026#34;/\u0026#34; pathType: Prefix backend: service: name: cookbook-webserver port: number: 80 Important is the line: traefik.ingress.kubernetes.io/router.middlewares: uitsmijter-forward-auth@kubernetescrd. This connects the ingress with Uitsmijter and only logged-in users are allowed to access the page. If a user is not logged in, then the users\u0026rsquo; client (browser) will be redirected to login.example.com and back after credentials are checked successfully.\nFurther readings Learn more about the Interceptor-Mode on this dedicated page See examples for the Interceptor-Mode Learn about 🔗 router.middlewares in Traefik ","description":"Walkthrough guide for securing static webserver resources The Project Setup In the quick start guide chapter we have designed a new application with two portals, four services and one user store. The quick start guide shows how to set up Uitsmijter as a multi-tenant, multi-client authorisation server.\nFor this additional walkthrough documentation we assume that a last-minute change request for the business hits the development team. The requirement is, that the company\u0026rsquo;s Design-Cookbook should be accessible for all partners."},{"id":9,"href":"/configuration/","title":"Configuration","parent":"Uitsmijter Documentation","content":" Configuration Entities Helm configuration parameters Tenant and client configuration Logging ","description":" Configuration Entities Helm configuration parameters Tenant and client configuration Logging "},{"id":10,"href":"/configuration/entities/","title":"Entities","parent":"Configuration","content":" Entities This document describes the different entities Uitsmijter uses internally. They are mentioned throughout the rest of the documentation. For a complete list of used terminology, see Terminology.\nTenant A tenant is the highest order entity in the system. Every tenant is isolated in its functions and can not share resources.\nEvery Tenant does have its own set of settings, providers and clients. Let\u0026rsquo;s have a look what this means in practice.\nExamples for tenants are\nDifferent companies sharing the same Kubernetes cluster Separated products that do not have anything in common Different publications from a publishing house Different sets of underlying user data used for authentication (e.g. internal vs. external users) Note: If you just have one set of resources to protect with the same underlying user data(base), you will typically have just one tenant.\nTenants have a name which is a human-readable string that will be displayed whenever the tenant comes in play. In kubernetes we prepend the namespace to make it cluster unique. Each tenant has a list of hosts that are assigned to it. A tenant must have at least one host, and it can have as many as needed. A host can not be shared between two tenants in the system! That is, because the tenant will be selected by the requested host only and a request thereby can not resolve into two tenants.\nLet\u0026rsquo;s imagine two tenants are set up in the following way:\nTenant 1 (\u0026ldquo;Cheese Corp\u0026rdquo;) cheese.example.com toast.example.org Tenant 2 (\u0026ldquo;Ham Publishing Group\u0026rdquo;) ham.test If the request is addressed to cheese.example.com or toast.example.org, the first tenant will match and their settings will be processed. If the request is addressed to ham.test, the second tenant will match and their settings will be processed. If a request goes to egg.example or any other host not specified in any tenant\u0026rsquo;s config, the request will be denied, because none of the tenants match the request. The authentication server itself does not have its own user database. Instead, each tenant must provide a set of providers that are responsible for validating the users with a backend system. Providers are written in JavaScript and do apply to all clients (see Providers).\nIt is possible to share the same backend providers by copying the provider scripts, but this is not recommended and should be considered to solve problems where this idea seams to be a good solution otherwise.\nClient A client is an external application that is allowed to use a grant and access protected resources on behalf of the resource owner (i.e. user). The client could be hosted on a server, desktop, mobile or other device.\nEach tenant can have multiple clients on different device classes such as:\nOne or multiple websites Mobile Apps (e.g. iOS or Android native apps) Multiple Microservices and APIs to access them It is advised to not mix or share clients between device classes. Instead, give every platform its own client for the following reasons:\nSecurity: If a token is leaked on one platform, the others are not involved. Flexibility: Sooner or later different devices will have different settings. A single sign on works between all clients. And because the providers are bound to tenants all clients will fetch the same backend service to fetch the users.\nFurther readings Tenant and client configuration Terminology overview ","description":"Entities This document describes the different entities Uitsmijter uses internally. They are mentioned throughout the rest of the documentation. For a complete list of used terminology, see Terminology.\nTenant A tenant is the highest order entity in the system. Every tenant is isolated in its functions and can not share resources.\nEvery Tenant does have its own set of settings, providers and clients. Let\u0026rsquo;s have a look what this means in practice."},{"id":11,"href":"/oauth/granttypes/","title":"Grant Types","parent":"OAuth","content":" Grant Types In OAuth 2.0, the term “grant type” refers to the way an application gets an access token. Uitsmijter supports several grant types.\nConfiguration Grant types can be set at Client level.\ngrant_types: - authorization_code - refresh_token - password If none of any grant type is specified, that authorization_code and refresh_token are enabled by default.\nAuthorization Code The authorization code flow is a way to grant access to a protected resource, such as an API, by an external client. This flow involves multiple steps, which can be summarized as follows:\nThe client makes a request to the authorization server, asking for permission to access the resource on behalf of the resource owner (e.g. user). This request typically includes information about the client, such as its name and the scope of access being requested. If the authorization server determines that the request is valid, it will redirect the user\u0026rsquo;s browser to the client\u0026rsquo;s redirect URI, along with an authorization code. This code is a temporary, one-time-use token that is meant to be exchanged for an access token. The user\u0026rsquo;s browser follows the redirect and sends the authorization code to the client. The client sends a request to the authorization server, asking to exchange the authorization code for an access token. This request includes the authorization code and other information, such as the client\u0026rsquo;s credentials and the redirect URI. If the authorization server determines that the request is valid, it will issue an access token to the client. The access token is a long-lived token that can be used to make authenticated requests to the protected resource. In summary, the authorization code flow is a way for a client to obtain an access token by redirecting the user to the authorization server and obtaining an authorization code, which is then exchanged for an access token. This flow is commonly used by web applications, as it allows the client to access resources on behalf of the user without having to handle the user\u0026rsquo;s credentials directly.\nThe following values must be set in the request for an access token:\nProperty Value Description grant_type authorization_code This tells the server we’re using the authorization_code grant type client_id UUID of the client The public identifier of the application that the developer obtained during registration client_secret (optional) Must be set if the client request an secret. Reed more on tenant and client config page scope (optional) If the application is requesting a token with limited scope, it should provide the requested scopes here code authorization code The previous requested authorisation code. See endpoints and OAuth flow Example curl -v \\ -X POST \\ -H \u0026#39;Content-Type: application/json\u0026#39; \\ -d \u0026#39; { \u0026#34;grant_type\u0026#34;: \u0026#34;authorization_code\u0026#34;, \u0026#34;client_id\u0026#34;: \u0026#34;D742D5BF-0402-4C04-9FF8-94C1D2DA5BE2\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;read learn\u0026#34;, \u0026#34;code\u0026#34;: \u0026#34;fuc6Ohah3ail\u0026#34; } \u0026#39; \\ \u0026#34;https://login.example.com/token\u0026#34; The server replies with an access token and a refresh token:\n{ \u0026#34;access_token\u0026#34;: \u0026#34;aoth5bie8eiy2iPhaeghai6aijahvaeshungae8phieva6tiebeequ6tushei3ei\u0026#34;, \u0026#34;refresh_token\u0026#34;: \u0026#34;DOO5AHD6SAi9PA1OOKIAZoOSHOHgO1TO\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 7200, \u0026#34;scope\u0026#34;: \u0026#34;read learn\u0026#34; } You can use that access_token to make request to API backends by setting the value to the authorisation header:\ncurl -v \\ -H \u0026#39;Content-Type: application/json\u0026#39; \\ -H \u0026#39;Authorisation: Bearer aoth5bie8eiy2iPhaeghai6aijahvaeshungae8phieva6tiebeequ6tushei3ei\u0026#39; \\ \u0026#34;https://api.example.com/resource\u0026#34; Refresh Token A refresh token flow is a way to obtain a new access token by using a refresh token, which is a special kind of token that is issued along with the access token. Refresh tokens are intended to be long-lived, and can be used to obtain a new access token when the original access token expires or becomes invalid. This flow involves the following steps:\nThe client makes a request to the authorization server, asking to exchange the refresh token for a new access token. This request typically includes the refresh token and other information, such as the client\u0026rsquo;s credentials. If the authorization server determines that the request is valid, it will issue a new access token to the client. The new access token will have a new expiration time, and can be used to make authenticated requests to the protected resource just like the original access token. This flow allows the client to continue accessing the protected resource even after the original access token has expired, without requiring the user to go through the authorization process again.\nThe following values must be set in the request for an access token:\nProperty Value Description grant_type refresh_token This tells the server we’re using the refresh token grant type client_id UUID of the client The public identifier of the application that the developer obtained during registration client_secret (optional) Must be set if the client request an secret. Reed more on tenant and client config page scope (optional) If the application is requesting a token with limited scope, it should provide the requested scopes here refresh_token token The previous requested refresh token that came with the last access token. Example curl -v \\ -X POST \\ -H \u0026#39;Content-Type: application/json\u0026#39; \\ -d \u0026#39; { \u0026#34;grant_type\u0026#34;: \u0026#34;refresh_token\u0026#34;, \u0026#34;client_id\u0026#34;: \u0026#34;D742D5BF-0402-4C04-9FF8-94C1D2DA5BE2\u0026#34;, \u0026#34;refresh_token\u0026#34;: \u0026#34;DOO5AHD6SAi9PA1OOKIAZoOSHOHgO1TO\u0026#34; } \u0026#39; \\ \u0026#34;https://login.example.com/token\u0026#34; The server replies with a fresh access token and a new refresh token:\n{ \u0026#34;access_token\u0026#34;: \u0026#34;ga2iqueikaathoiK8Aeghiew5oos5phohtaize3dimiev8ooDautha3mipei6dee\u0026#34;, \u0026#34;refresh_token\u0026#34;: \u0026#34;EINA6AITHODAHTHAHBAYAEXAUDAIQU6D\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 7200, \u0026#34;scope\u0026#34;: \u0026#34;read learn\u0026#34; } You can use that new access_token to make request to API backends by setting the value to the authorisation header:\ncurl -v \\ -H \u0026#39;Content-Type: application/json\u0026#39; \\ -H \u0026#39;Authorisation: Bearer ga2iqueikaathoiK8Aeghiew5oos5phohtaize3dimiev8ooDautha3mipei6dee\u0026#39; \\ \u0026#34;https://api.example.com/resource\u0026#34; Password Clients explicitly have to turn on the password grant type to support it!\nThe password grant type should be used for testing purposes only. In OAuth the password grant type is often called implicit grant flow. The user directly sends the username and the cleartext password to the Authorization server and receives a valid access token when the credentials match.\nThe returned token contains only a valid access token without a refresh token. Users with this kind of token pair have to log in again after the valid token period expires.\nIf you ask yourself if you should implement a password grant type for your application, the answer is: No! Consider to use a authorization code grant type instead.\nATTENTION The implicit grant type causing the authorization server to issue access tokens in the authorization response. The tokens are vulnerable to access token leakage and access token replay.\nIn order to avoid these issues, clients SHOULD NOT use the implicit grant and any other response type causing the authorization server to issue an access token in the authorization response.\nSo why this type is implemented? Besides testing purposes, some legacy clients require this grant type. Uitsmijter is build from ground up to support migration projects. If you do have some kind of application in your tech-stack, you may want to turn this grant type on for development. Please migrate your app to authorization code grant type before going life.\nThe following values must be set in the request for an access token:\nProperty Value Description grant_type password This tells the server we’re using the password grant type client_id UUID of the client The public identifier of the application that the developer obtained during registration client_secret (optional) Must be set if the client request an secret. Reed more on tenant and client config page scope (optional) If the application is requesting a token with limited scope, it should provide the requested scopes here username The user’s username that they entered into the application password The user’s password that they entered into the application Example curl -v \\ -X POST \\ -H \u0026#39;Content-Type: application/json\u0026#39; \\ -d \u0026#39; { \u0026#34;grant_type\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;client_id\u0026#34;: \u0026#34;e92b4a0b-d1d7-4d55-b2e3-dc570faca745\u0026#34;, \u0026#34;client_secret\u0026#34;:\u0026#34;luaTha1qu019ohc13qu3ze1yuo5MumEl0hQuoE9bon\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;read learn\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;testuser@example.com\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;Tes1Pas5w0r1\u0026#34; } \u0026#39; \\ \u0026#34;https://login.example.com/token\u0026#34; The server replies with an access token:\n{ \u0026#34;access_token\u0026#34;: \u0026#34;MTQ0NjOkZmQ5OTM5NDE9ZTZjNGZmZjI3\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 7200, \u0026#34;scope\u0026#34;: \u0026#34;read learn\u0026#34; } You can use that access_token to make request to API backends by setting the value to the authorisation header:\ncurl -v \\ -H \u0026#39;Content-Type: application/json\u0026#39; \\ -H \u0026#39;Authorisation: Bearer MTQ0NjOkZmQ5OTM5NDE9ZTZjNGZmZjI3\u0026#39; \\ \u0026#34;https://api.example.com/resource\u0026#34; Further readings Available Endpoints Client side JWT Decoding Authorization Code Flow with Proof Key for Code Exchange ","description":"Grant Types In OAuth 2.0, the term “grant type” refers to the way an application gets an access token. Uitsmijter supports several grant types.\nConfiguration Grant types can be set at Client level.\ngrant_types: - authorization_code - refresh_token - password If none of any grant type is specified, that authorization_code and refresh_token are enabled by default.\nAuthorization Code The authorization code flow is a way to grant access to a protected resource, such as an API, by an external client."},{"id":12,"href":"/interceptor/interceptor/","title":"Interceptor Mode","parent":"Interceptor","content":" Interceptor Mode Interceptor mode is used within Traefik2 as a middleware authorization controller. When a resource is requested the middleware checks if the current user is logged in. If not, the request is redirected to the login page. If the user making the request is logged in, then the middleware forwards the request to the requested resource.\nFor other ingress controllers support please feel free to contact our development and consulting team. We are constantly adding support for other controllers and document them if needed.\nFlow ┌────────────────────────┐ ┌────────────────────────┐ ┌───────────────────────┐ │ │ │ │ │ │ │ │ request \u0026gt; │ │ ok \u0026gt; │ │ │ ├───────────────► ├────────────► │ │ Resource owner │ │ AuthForward │ │ resource server │ │ ◄───────────────┤ │ │ │ │ │ \u0026lt; error │ │ │ │ └────────────────────────┘ └──────────────────▲──┬──┘ └───────────────────────┘ │ │ │ │ │ │ ┌──┴──▼────────────────────┐ │ │ │ │ │ │ │ Uitsmijter │ │ │ │ │ └──────────────────────────┘ The resource owner makes a request to the resource server The AuthForward delegates the request to Uitsmijter first If the user is not logged in, a login mask is provided If the login fails, the AuthForward responds with an error code If the login succeeded, or the user is already logged in, Uitsmijter adds the JWT to the header and the AuthForwarder forwards the request to the resource server. Login status The status whether a user is logged in or not is stored in a cookie that is strictly bound to the domain of the middleware. The domain must be set at tenant level, shown in the example section. Inside the cookie there is an encoded JWT stored. This JWT will be added to the Authorization header for every request.\nIn your application:\nDo not read the cookie yourself, but use the Authorization header sent with the request.\nRefresh the token The middleware will refresh the requests JWT automatically, when 3/4 of the lifetime was passed.\nThis could potentially lead to a situation where two different valid JWTs arrive at the underlying application, in case the application fires parallel requests against themselve. Even both tokens are valid and encode the same information, some applications may not like this when storing the original token. The solution for this scenario is easy: validate the token as soon as possible and decode the payload first. Save the decoded payload for comparison, not the token. This \u0026ldquo;problem\u0026rdquo; is just an academic one, because if your application makes a request with a token which is already known you are in the Single-Page-Application landscape already. In this case please use a proper OAuth-Flow instead. In a server rendered application a parallel request with different tokens will never be a problem if you decode the payload first.\nConfiguration and Examples To protect your resource server with the interceptor mode of Uitsmijter, you mainly need to add an ingress annotation:\nannotations: traefik.ingress.kubernetes.io/router.middlewares: uitsmijter-forward-auth@kubernetescrd If your setup works on the same top level domain, then that is everything needed. For example, Uitsmijter\u0026rsquo;s main domain is: login.example.com and the resource server to protect is located at secured.example.com.\nA bit more tricky is when projects are at different top level domains. For example the Uitsmijter installation is still located at login.example.com, but the resource server to protect is located at toast.example.com. Because cookies must be from within the same domain, the trick is to proxy the service into the new domain via an 🔗 external service and then defining an own ingress to that service.\nCookie settings The cookie must be set for the domain in which both the Uitsmijter service (or its ingress to the proxy) and the resource server are located!\nAttention: Every backend service that is located on this domain or a subdomain of this domain can read the JWT out of the cookie. It is accessible to all services on this domain tree.\nExample:\nUitsmijter is accessible at id.example.com The resource server is accessible at secretinfo.srv.example.com Then you have to set example.com as tenants interceptor.cookie domain If Uitsmijter is installed onto a server without Kubernetes, you have to be sure that the environment is set correctly. Installations outside Kubernetes is not documented, yet. If you have any questions please do not hesitate to ask\nInstall this proxy service to a new namespace. It links to Uitsmijter:\n--- kind: Service apiVersion: v1 metadata: name: uitsmijter-proxy spec: type: ExternalName externalName: uitsmijter-authserver.uitsmijter.svc.cluster.local ports: - port: 80 save this to uitsmijter-proxy.yaml file\nThis external service defines a proxy into the authentication server in the uitsmijter namespace. You can create this service in every namespace on your cluster.\nEnsure Uitsmijter is installed properly in the uitsmijter namespace. (If not set up yet, please read the quick start now.) Create (if not done by now) a namespace for the resource server: kubectl create namespace \u0026#34;my-resources\u0026#34; Apply the proxy service mentioned above: kubectl apply -n \u0026#34;my-resources\u0026#34; -f uitsmijter-proxy.yaml When the resource server is available at toast.example.com a login page at the same domain level is needed, like login.example.com for example.\nThis is an example ingress that points to the proxy service and serves uitsmijter from the new domain.\n--- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: uitsmijter annotations: traefik.ingress.kubernetes.io/router.entrypoints: websecure traefik.ingress.kubernetes.io/router.tls: \u0026#34;true\u0026#34; traefik.ingress.kubernetes.io/router.middlewares: uitsmijter-forward-header@kubernetescrd spec: tls: - secretName: example.com rules: - host: login.example.com http: paths: - path: \u0026#34;/\u0026#34; pathType: Prefix backend: service: name: uitsmijter-proxy port: number: 80 An ingress can only refer to a service in the same namespace, but a service can address a resource in another namespace. This is why we have to do both: a proxy service and an ingress to the proxy service.\nDo not overlook this line: traefik.ingress.kubernetes.io/router.middlewares: uitsmijter-forward-header@kubernetescrd\nIt is important to set specific headers that Uitsmijter needs for proper operation.\nTo protect static resources, like discussed in the Walkthrough guide for securing static webserver resources all to do is to define a tenant next\nLet\u0026rsquo;s create a file for the example-tenant named example-tenant.yaml:\n--- apiVersion: \u0026#34;uitsmijter.io/v1\u0026#34; kind: Tenant metadata: name: example spec: hosts: - login.example.com - toast.example.com interceptor: enabled: true domain: login.example.com cookie: .example.com informations: imprint_url: https://example.com/imprint privacy_url: https://example.com/privacy register_url: https://login.example.com/register providers: - class UserLoginProvider { constructor(credentials) { commit(true); } get canLogin() { return true; } get userProfile() { return {message:\u0026#34;DO NOT USE THIS IN PRODUCTION\u0026#34;}; } get role() { return \u0026#34;development\u0026#34;; } } - class UserValidationProvider { constructor(args) { commit(true); } get isValid() { return true; } } The UserLoginProvider accepts every combination of any user for now. We can change it later.\nApply the tenant and restart Uitsmijter to load the new tenant: kubectl apply -n \u0026#34;my-resources\u0026#34; -f example-tenant.yaml kubectl delete pod -n uitsmijter -l app=uitsmijter -l component=authserver When a user requests https://toast.example.com the first time the browser will be redirected to the Uitsmijter login page at https://login.example.com. After login successfully the user will redirect back to https://toast.example.com. A cookie is stored at the users browser for all domains in the .example.com landscape, including toast.example.com - but also egg.example.com. Maybe this is what you want, otherwise fine tune the interceptor.cookie settings in the tenant definition file. If you do not want to allow an SSO to all the subdomains at *.example.com, but just and only to toast.example.com, change the interceptor.cookie setting to toast.example.com. Remember that the login page must be part of the domain-scope. Maybe you want to change the ingress from the domain login.example.com to toast.example.com/login.\nAdvanced configuration for applications behind the Interceptor-Mode Protecting a static web server behind Uitsmijter is very simple, as the chapter up to here could show. The static websites do nothing with the authorisation header set by Uitsmijter. It just has to be present.\nA very little more difficult is when a server side rendering application sits behind the protected resources that has to know something about the concrete user and maybe has to decode the profile from the Bearer token.\nThe application has to validate the JWT with a shared secret, checks that the token is still valid and then decode the profile from it.\nBut first things first: sharing the secret. While installation a shared secret is given (see Quick Start Guide for Kubernetes for more details on how to set a secret into the Values.yaml). For installations outside of Kubernetes ensure that the environment variable JWT_SECRET is set.\nWhen Uitsmijter is installed on Kubernetes with the provided Helm Chart and all requirements are met. Sharing the JWT-secret into namespaces that needs them to validates the JWT is easy. Uitsmijter sets annotations for 🔗 config-syncer. All the other namespace has to do is set the labels to the namespace, too.\nHere is an example namespace definition for my-resources:\n--- apiVersion: v1 kind: Namespace metadata: name: my-resources labels: jwt-secret/sync: \u0026#34;true\u0026#34; jwt-secret/sync: \u0026quot;true\u0026quot; will sync the secret into the namespace. To have the content in your applications environment you should link the secret to your environment:\n#[ ... _deployment_ ... ] envFrom: - secretRef: name: jwt-secret #[ ... _rest_of_the_deployment_ ... ] More information about environment variables in Kubernetes are described in 🔗 Define Environment Variables for a Container\nWith the information about the secret attached to the namespace and bind to the environment variable the application can validate and decode the token.\nDo not track the user on information inside the tokens profile, use the token.subject instead. The Subject is an unique identifier for your user across all systems. The subject inside a token is set by the User Login Provider. You can find any information on the page about them.\nHow to validate and decoding a JWT depends on your server programming language, here is a code for nodejs using the jsonwebtoken library from auth0.\nconst jwt = require(\u0026#39;jsonwebtoken\u0026#39;); // Verify the token using jwt.verify method const decode = jwt.verify(token, \u0026#39;secret\u0026#39;); const subject = decode.sub; const profile = decode.profile; // show the full decoded token console.log(JSON.stringify(decode, null, 4)); The result should look something like this:\n{ \u0026#34;tenant\u0026#34;: \u0026#34;my-resources/my-tenant\u0026#34;, \u0026#34;profile\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34; }, \u0026#34;sub\u0026#34;: \u0026#34;188920\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;user\u0026#34;: \u0026#34;john@example.com\u0026#34;, \u0026#34;exp\u0026#34;: 1671740462.505093 } In the result above a numeric id is chosen by the User Backend Provider to identify the concrete user.\nMetrics Metrics about succeeded and failed calls are metered by these Prometheus keys:\nuitsmijter_interceptor_failure uitsmijter_interceptor_success uitsmijter_login_attempts uitsmijter_login_failure uitsmijter_login_success Technical details Whether the user is logged in or not is persisted by a restricted cookie with the content of the JWT. Uitsmijter does not track any sessions for the middleware requests.\nFurther readings In the interceptor example section the demopage is described and explained in detail. ","description":"Interceptor Mode Interceptor mode is used within Traefik2 as a middleware authorization controller. When a resource is requested the middleware checks if the current user is logged in. If not, the request is redirected to the login page. If the user making the request is logged in, then the middleware forwards the request to the requested resource.\nFor other ingress controllers support please feel free to contact our development and consulting team."},{"id":13,"href":"/general/terminology/","title":"Terminology","parent":"General","content":" Terminology Access token - A token used to access protected resources. Authorization code - An intermediary token generated when a user authorizes a client to access protected resources on their behalf. The client receives this token and exchanges it for an access token. Authorization server - A server which issues access tokens after successfully authenticating a client and resource owner, and authorizing the request. Client - An application which accesses protected resources on behalf of the resource owner (such as a user). The client could be hosted on a server, desktop, mobile or other device. See also Configuration/Client. Grant - A grant is a method of acquiring an access token. Also see the official documentation for common grant types. Resource server - A server which sits in front of protected resources (for example “tweets”, users’ photos, or personal data) and is capable of accepting and responding to protected resource requests using access tokens. Resource owner - The user who authorizes an application to access their account. The application’s access to the user’s account is limited to the “scope” of the authorization granted (e.g. read or write access). Scope - A permission. Tenant - The tenant serves as the top entity and is responsible for connecting users/apps to a backend service. A Tenant can be a company or a product with unique user group. It has Clients which represent different applications. See also Configuration/Tenant. JWT - A JSON Web Token is a method for representing claims securely between two parties as defined in RFC 7519. Provider - A provider are lightweight scripts that establish a seamless connection between Uitsmijter and a user data store ","description":"Terminology Access token - A token used to access protected resources. Authorization code - An intermediary token generated when a user authorizes a client to access protected resources on their behalf. The client receives this token and exchanges it for an access token. Authorization server - A server which issues access tokens after successfully authenticating a client and resource owner, and authorizing the request. Client - An application which accesses protected resources on behalf of the resource owner (such as a user)."},{"id":14,"href":"/contribution/tooling/","title":"Toolchain","parent":"Contribution","content":" Commandline Tool To Build Uitsmijter - Tooling.sh A build tool is a set of tools that automate the process of testing, compiling, assembling, and packaging source code into executable software. Build tools are an essential part of the software development lifecycle, helping developers manage the complexity of building, testing, and deploying software.\nFor Uitsmijter we build a toolchain that help developers to set up the environment to work easily with the code. As easy it is to use Uitsmijter, it should also be easy for developers to work with the source code. We automate many repetitive and error-prone tasks and describe those in maintainable bash scripts.\nTooling collects a set of functions that build, lint, test, e2e test and run the project in a docker compose environment and in a local test cluster provided by 🔗 kind. The setup uses fast incremental builds and supports the developers to create a consistent workflow where questions can be clarified quickly among each other.\nPlease use builds with the tooling setup only to request support. This tool ensures that errors can be traced and makes it easier for everyone to understand the request.\nTooling help to maintain consistency in the development and build process. Regardless of the developer\u0026rsquo;s machine or the development environment, the build tool ensures that the software can be built and tested in a predictable manner.\nIf you are new to Uitsmijter development, code provides you with a ready-to-use IDE in your browser to get you started.\nInterface $ ./tooling.sh Uitsmijter Tooling ******************************************************************************************************************************************************************************************************** ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~ Branch: main | Version: ce-0.9.6 ~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Choose one or more commands: -rm | --remove | remove Remove docker volumes, images and build directory -b | --build | build Build the project -l | --lint | lint Check code quality -t | --test | test Run all UnitTests -e | --e2e | e2e Run end-to-end tests -r/-c | --run[-cluster] | run[-cluster] Run Uitsmijter in docker or in a local kind-cluster -s | --release | release Build a release version, can have an optional added image name (with optional tag) -p | --helm | helm Build the helm package | --code | code Open a code editor -h | --help | help Show this help message Additional Parameters: --rebuild Force rebuild images --debug Enable debug output --dirty Use incremental temporary runtime for the local cluster --fast runs tests only on one virtual browser and resolution. Example: ./tooling build run ./tooling -b -r -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Documentation can be found at https://docs.uitsmijter.io ******************************************************************************************************************************************************************************************************** * done. * ******************************************************************************************************************************************************************************************************** Whohoo that are a lot of options! Don\u0026rsquo;t panic! We\u0026rsquo;ll discuss each command in a second. But first let\u0026rsquo;s see how to use these options on command line.\nEvery option can be chained. Instead of build first and test then, like:\n$ ./tooling.sh build [...] $ ./tooling.sh test [...] You may want to chain them together:\n$ ./tooling.sh build test You can add double hyphens or omit them ./tooling.sh --build is the same as ./tooling.sh build. Commands have a long-hyphens and a short-hyphens form: ./tooling.sh --build is the same as ./tooling.sh -b. Depending on your taste you can choose between: build, --build or -b which is all the same. In general, we recommend to use the command- style (like: build) to call the build, but for scripting the automation tool it can be handy to have the other options as well. In this documentation only command-style (without hyphens) will be used.\nCommands remove Removes the local Docker containers, images and volumes, as well as the local .build-cache.\n./tooling.sh remove Removing all images gives recovering your environment from all Uitsmijter related containers and enforce build to build the sources from scratch.\nAfter removing all corresponding images, build, test, e2e and code needs to pull the base images from the registry again.\nbuild Setup and build the project in a linux container for the current platform.\n./tooling.sh build After completion of the build, a Uitsmijter binary can be found in ./Deployment/Release/Linux/Uitsmijter. On macOS this file is not very usable on the local machine, because it is made to run inside a docker-runtime. The run command uses the build command to build a binaray that can be run in your local docker environment. The tests compile the code with debug flags and the release command ensure that everything is build from scripts. To work with tests or to run code changes on your local machine, build as a standalone command is not needed. Nevertheless, build is a useful command that is often used while developing, because build builds the source code incremental and it is the fastest way to check if the code can compile.\nBefore you try anything else, run build to see if the code is ready and can compile.\nThe first build will take a long time. After the first build is will take seconds, only.\nlint Run 🔗 swiftlint on the project.\n./tooling.sh lint The Uitsmijter community strictly enforces code styles. All rules are defined in ./.swiftlint.yml. Code that violates the rules can not be committed! To check if the code is clean to commit, run tooling.sh lint. In the case of errors and warnings, there is a list of violations against the ruleset along the file and the line.\nBefore you commit a feature, run lint to see that the commit would be accepted technically.\ntest Uitsmijter source code have a lot of 🔗 UnitTests that covers a lot of internal functions and ensure the functionality of them. New features that introduces new functions to the codebase should also deliver new UnitTests. To run the test, swift test compiles the code incrementally and test all test suites. After the test a coverage reports is generated.\n./tooling.sh test e2e Besides the bespoken UnitTests, e2e runs end-to-end tests which can be found as shell scripts in /Tests/e2e/. A local 🔗 kind k8s test cluster is started to run a production release of Uitsmijter along a set of tenant and client test-configurations.\nThe test cluster runs the latest release build which can be reached via https://uitsmijter.localhost if no other option is set. ./tooling.sh e2e is the same as ./tooling.sh release e2e.\n./tooling.sh e2e Building a full release from scratch, starting a cluster and run all e2e-tests takes a long time but is essential to ensure that the release really works. Every developer should run at least one final e2e test on a fresh release. For developing this can be annoying when a release-build takes up to 10 - 20 minutes (depending on the power of the machine). The fact that e2e-tests should run on a fresh production release only (at least in the ci) is the reason that this is the default for the e2e command. This can be lead in a very unproductive and frustrating day, obviously. When working on the e2e-tests that is not a problem, becuase run-cluster starts Uitsmijter in a local cluster and the e2e-tests can be executed locally while development. But if a developer need to check multiple times if a code change fixes a test-assertion-error then building a full release every time is not going to work. Therefore, it is possible to test on a dirty incremental build as well. Internally, instead of using a release for running the e2e tests a build is used. This only takes seconds instead of multiple minutes. To use the incremental builds attach the option --dirty to the command.\n./tooling.sh e2e --dirty Do never ever use a \u0026ndash;dirty flag in a CI! The safety of a fresh (non cached) release is always more important than saving CI-hours. Use --dirty in your own workflow only.\nrun Start the Uitsmijter server localy for testing in a docker environment. It can be reached at http://localhost:8080. The run command executes a incremental build first, so runis the same as build run.\n./tooling.sh run The run command is usefully to check implementations that do not need further environments fast. It will run a single docker container at the local machine and bind port 8080 to it. Run loads the default tenant and the default client only. You may want to add more testing tenants at runtime to ./Resources/Configuration. The run command binds this directory and auto-refreshes the configuration without a restart (hot reload).\nrun-cluster To run a more sophisticated environment and to check the kubernetes features, a local cluster with a lot of preinstalled applications (tenants and clients) can run on the local machine as well. The tool chain uses 🔗 kind to set up a local k8s test cluster.\nWith the generated KUBECONFIG (located in ./.build/kubeconfig) kubectl can be used to operate the cluster. The test cluster runs the latest release build which can be reached via https://uitsmijter.localhost. Again, a release ensures that the production release is build from scratch first. This takes a lot of time. Because this is not productive when developing features a --dirty option can be passed.\nWhen run-cluster is executed, a list of test domains is output. To use these, they must be entered in the /etc/hosts file. A list of domains and user/password combinations can be found on the dedicates test cluster page.\n./tooling.sh run-cluster is the equivalent for release run-cluster.\nor\n./tooling.sh run-cluster --dirty is the equivalent for build run-cluster.\nrelease Build the release image which contains the Uitsmijter server without development tooling. Release build an official image and generates helm chats for that.\n./tooling.sh release It is not possible to run a release command with the --dirtyoption! A release is always a production artifact and ensures that is made from a non cached version.\nheml The Uitsmijter Project contains 🔗 Helm templates. Use this command to package these charts into a .tgz file that can be found at /Deployment/Release/uitsmijter-\u0026lt;version\u0026gt;-\u0026lt;build\u0026gt;-\u0026lt;hash\u0026gt;.tgz.\nIf you are contributing to the public open source project, you do not need to build the packages, but if you are using Uitsmijter in a private repository, you may want to maintain your own chats. This command will help you to maintain these chats.\n./tooling.sh helm In your CI you may want to use this in conjunction:\n./tooling.sh test release helm code As an experienced developer who works a lot in and with Uitsmijter, you certainly have your preferred local development environment in which you like to work. The developers of the code all prefer other environments, whether Xcode, CLion, AppCode, Visual Studio Code, or vi. Uitsmijter does not tell you what to develop in.\nWe welcome you to participate in the development, and we know how challenging it can be to set up and adjust everything from the checkout of the project to the first commit. We want to make your experience as pleasant as possible and allow you to get a taste of the project without any effort. That\u0026rsquo;s why Uitsmijter provides you with a ready-to-run IDE with the code. This runs in your browser and has all the settings for coding, testing and debugging already preset. Of course, you can customize the look \u0026amp; feel and adapt it to your needs.\nJust give it a try. Rumor has it that even project maintainers prefer to use this function for more and more tasks in the code.\n./tooling.sh code Note: Tests are slower in the IDE than via ./tooling.sh test, as they can only run on one worker. However, it is possible to execute individual tests and set breakpoints in the code.\nhelp The help command show a list of available commands and options.\n./tooling.sh help Additional Parameters force rebuild Docker compose scripts rely on images, especially for incremental builds and e2e testing. If the images already exist, they are not rebuilt unless --rebuild is provided. Rebuilding the images is highly recommended on continuous integration build servers, otherwise changes in the scripts of the supported containers such as the e2e.Dockerfile will be ignored if an older image is still present on the system where the build runner exists.\n./tooling.sh e2e --rebuild debug output To see what the build tool is doing, pass --debug to the command. Debug outputs shows every command that the automation scripts are doing onto the terminal output.\n./tooling.sh build --debug use dirty build To speed up the local development it is not nessasarry to build a compleate release every time. In this case a --diry option can be passed to e2e and run-cluster to use the incremental development build as a runtime images for the cluster.\n./tooling.sh e2e --dirty use fast e2e tests The end-to-end tests are carried out in various browsers with desktop and mobile screen resolutions. This is of course good to be sure that Uitsmijter works flawlessly in different environments and that a high-quality version can be built. Nevertheless, during development it is sometimes necessary to run all e2e tests quickly. The parameter \u0026lsquo;fast\u0026rsquo; restricts the execution to a browser with only one resolution.\n./tooling.sh e2e --fast Used Dockerfile The tooling.sh script uses dockerfiles located in Deployment/ and the 🔗 docker-compose file at: Deployment/docker-compose.yml\nRun through tooling and get familiar with the tool cahin We discussed every option of ./tooling.sh in this section but the best way to understand it and get familiar with the functions is to use it. Follow this steps to see what it is doing by your own.\nAfter checking out the code lets see the options first:\n$ ./tooling.sh Uitsmijter Tooling •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••• ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~ Branch: main | Version: 1.0.0 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Choose one or more commands: -rm | --remove | remove Remove docker volumes, images and build directory -b | --build | build Build the project -l | --lint | lint Check code quality -t | --test | test Run all UnitTests -e | --e2e | e2e Run end-to-end tests -r/-c | --run[-cluster] | run[-cluster] Run Uitsmijter in docker or in a local kind-cluster -s | --release | release Build a release version, can have an optional added image name (with optional tag) -p | --helm | helm Build the helm package | --code | code Open a code editor -h | --help | help Show this help message Additional Parameters: --rebuild Force rebuild images --debug Enable debug output --dirty Use incremental temporary runtime for the local cluster --fast runs tests only on one virtual browser and resolution. Example: ./tooling build run ./tooling -b -r -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Documentation can be found at https://docs.uitsmijter.io ******************************************************************************************************************************************************************************************************** * done. * ******************************************************************************************************************************************************************************************************** Do a build first to check if it compiles:\n./tooling build [...] This took a hugh amount of time\u0026hellip;. On an Apple M1 Max, 64 GB it took round about 5 Minutes. Let\u0026rsquo;s do it again:\n./tooling build [...] Ok, that was much faster! It only took 13 Seconds. You understand the benefits of incremental builds, now.\nLet\u0026rsquo;s see how to use the other commands. Is the code tidy?\n$ ./tooling lint Check code style ========================================================================================================== [ { \u0026#34;check_name\u0026#34; : \u0026#34;Trailing Comma\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;Collection literals should not have trailing commas.\u0026#34;, \u0026#34;engine_name\u0026#34; : \u0026#34;SwiftLint\u0026#34;, \u0026#34;fingerprint\u0026#34; : \u0026#34;2ab8228b061728b140fa84ed524708f0a79a8e1cc9b25f1b0c50ef7b097a9f8c\u0026#34;, \u0026#34;location\u0026#34; : { \u0026#34;lines\u0026#34; : { \u0026#34;begin\u0026#34; : 19, \u0026#34;end\u0026#34; : 19 }, \u0026#34;path\u0026#34; : \u0026#34;Tests/ServerTests/Login/LoginControllerTests+Profile.swift\u0026#34; }, \u0026#34;severity\u0026#34; : \u0026#34;MINOR\u0026#34;, \u0026#34;type\u0026#34; : \u0026#34;issue\u0026#34; } ] Done linting! Found 1 violations, 0 serious in 153 files. Oups, what do we have here? There is one violation in a UnitTest file. A Collection literals should not have trailing commas.. We can fix this in Tests/ServerTests/Login/LoginControllerTests+Profile.swift at line 19.\nBut first let\u0026rsquo;s go on and run all UnitTests:\n$ ./tooling lint deployment-test-1 | Uitsmijter deployment-test-1 | ------------------------------------------------------------ deployment-test-1 | Build info: deployment-test-1 | 0|12|9|3 deployment-test-1 | Running tests with 8 workers. [...] eployment-test-1 | INFO: The optimized code generation is disabled deployment-test-1 | Warning: LLVM version has changed. Parsing may fail. deployment-test-1 | Checking Project Requirements... deployment-test-1 | Tests: OK There are a few things to mention:\nIt compiles the code with development features embedded. This will take some time, because switching from build to test recompiles development features in. Running test twice in a row do only recompile changes in code or tests. Of course this is way faster. switching from build to test changes the development features and should be avoided. DO NOT RUN ./tooling.sh build test. The line: Build info: 0|12|9|3 is important. The last number 3 is the incremental run on the build. It will increase every time a test is run (0|12|9|4, 0|12|9|5, \u0026hellip;). If this number is high and test results are questionable, try to force rebuild the code. If a test fails, the reason will be printed out.\nLet\u0026rsquo;s run Uitsmijter in development:\n$ ./tooling.sh run [...] Run incremental build in a docker environment ================================================================================ [+] Running 3/3 ✔ redis [...] Attaching to deployment-run-1 deployment-run-1 | Uitsmijter deployment-run-1 | ------------------------------------------------------------ deployment-run-1 | +------+------------------+ deployment-run-1 | | GET | / | deployment-run-1 | +------+------------------+ deployment-run-1 | | GET | /health | deployment-run-1 | +------+------------------+ deployment-run-1 | | GET | /versions | deployment-run-1 | +------+------------------+ deployment-run-1 | | GET | /metrics | deployment-run-1 | +------+------------------+ deployment-run-1 | | GET | /login | deployment-run-1 | +------+------------------+ deployment-run-1 | | POST | /login | deployment-run-1 | +------+------------------+ deployment-run-1 | | GET | /logout | deployment-run-1 | +------+------------------+ deployment-run-1 | | POST | /logout | deployment-run-1 | +------+------------------+ deployment-run-1 | | GET | /logout/finalize | deployment-run-1 | +------+------------------+ deployment-run-1 | | GET | /interceptor | deployment-run-1 | +------+------------------+ deployment-run-1 | | GET | /authorize | deployment-run-1 | +------+------------------+ deployment-run-1 | | POST | /token | deployment-run-1 | +------+------------------+ deployment-run-1 | | GET | /token/info | deployment-run-1 | +------+------------------+ deployment-run-1 | Starting Uitsmijter... deployment-run-1 | 2023-09-24T12:06:42+0000 error codes.vapor.application : [Vapor] Application.shutdown() was not called before Application deinitialized. deployment-run-1 | [INFO] Sun, 24 Sep 2023 12:06:42 GMT: Current Loglevel is [debug] deployment-run-1 | [INFO] Sun, 24 Sep 2023 12:06:42 GMT: Uitsmijter Version: dirty deployment-run-1 | [INFO] Sun, 24 Sep 2023 12:06:42 GMT: Boot redis deployment-run-1 | [INFO] Sun, 24 Sep 2023 12:06:42 GMT: Found 1 resources in /app/Resources/Configurations/Tenants deployment-run-1 | [INFO] Sun, 24 Sep 2023 12:06:42 GMT: Add new tenant \u0026#39;Uitsmijter\u0026#39; with 3 hosts deployment-run-1 | [INFO] Sun, 24 Sep 2023 12:06:42 GMT: Found 2 resources in /app/Resources/Configurations/Clients deployment-run-1 | [INFO] Sun, 24 Sep 2023 12:06:42 GMT: Add new client \u0026#39;secretclient\u0026#39; [B948FFA3-BEE5-4992-BEBE-B581308E6E1D] for tenant \u0026#39;Uitsmijter\u0026#39; deployment-run-1 | [INFO] Sun, 24 Sep 2023 12:06:42 GMT: Add new client \u0026#39;Localclient\u0026#39; [66CC4B67-7BED-48E8-AE2E-8A6DBE07B879] for tenant \u0026#39;Uitsmijter\u0026#39; deployment-run-1 | [NOTICE] Sun, 24 Sep 2023 12:06:42 GMT: Server starting on http://0.0.0.0:8080 It first starts a local 🔗 redis in docker and then builds the runtime, if not present on your machine. The runtime will link the Uitsmijter binary from the build step as a volume into the container.\nNote that run uses the Uitsmijter from the project/Deployment/Release/Linux directory as a Link. The Runtime did not have a baked in copy of the binary. Therefore run implicit uses a build first.\nOpen your browser at https://localhost:8080/:\n$ curl http://localhost:8080/versions dirty You see that you are not at a release and the version is dirty.\nIf you run Uitsmijter in a local cluster, the tooling scripts will build a release first. Let\u0026rsquo;s take the time and do it for demonstration purpose:\n$ ./tooling.sh run-cluster Run release in local KubernetesInDocker ================================================================================ Build a fresh production release ================================================================================ [+] Building ... Ok, honestly\u0026hellip; time for a coffee.\nBecause run-cluster needs a release version and a helm package that can be deployd onto the cluster, the full release will be run first. That takes a lot of time, because it will generate a docker image from scratch without any caches. That includes:\nupdating the docker image os downloading packages compile everything for testing running UnitTests recompile for production build a standalone runtime copy artifacts from one image to the other Regardless how often release or run-cluster or e2e is called, it will always take the time to rebuild everything from scratch to ensure a full atomically build deliverable that can\u0026rsquo;t be faked. If this works and an image is made successfully, then it is ready to run on production servers.\nThe scripts are made with the ideas in mind, that it is possible to create a production release only with a valid version of the source code. There should be no way to accidentally release a broken version.\nBack to output of run-cluster:\n[...] Checking requirements --------------------------------------------------------------------------------------- [...] To run Kubernetes on your machine you need a few tools installed. The script checks for existence.\nkubectl helm gdate (on macOS only) [...] Setup cluster --------------------------------------------------------------------------------------- [...] Setting up environment --------------------------------------------------------------------------------------- [...] Setup Uitsmijter --------------------------------------------------------------------------------------- [...] Uitsmijter will be installed from your production image build locally via helm. run-cluster will also install some demo application that are used in the e2e tests, too:\n⬇ Install application BNBC -------------------------- [...] ⬇ Install application Ham ------------------------- [...] ⬇ Install application Cheese ---------------------------- You can find information about the test applications at ./Tests/e2e/readme.md.\nCluster is running. Add the following to your local /etc/hosts file. 127.0.0.1 api.example.com 127.0.0.1 [...] # and others Press enter to stop the cluster To use the test applications you have to add a lot of hosts to your local /etc/hosts file (or to your local DNS).\nOk, lets add them to /etc/hosts and fetch the version of Uitsmijter again:\n$ curl -k https://uitsmijter.localhost/versions 0.9.2-135-g1dbcb33-dirty As we write this documantation we are on Version 0.9.2 and we have some new or changed files in the git commit with the hash g1dbcb33. Because the git status is not committed yet, a -dirty is attached to the version.\nIf we run ./tooling.sh without any command we will see that info too:\n$ ./tooling.sh Uitsmijter Tooling ••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••• ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~ Branch: feature-UIT-422-improve-tooling | Version: 0.9.2-135-g1dbcb33 ~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ [...] You see, that I am working in a git branch named feature/UIT-422-improve-tooling. The last commited tag was 0.9.2 and since then 135 commits are done. I am on revision g1dbcb33. This information is reflected in the version sting returned by the /version route.\nNow, because Uitsmijter is running iun Kubernetes, we kann use kubectl to control the deployment, the Tenant and Client configuration, see, logs, test auto-scaling, and so on.\nFor example lets increase the running pods :\n$ kubectl --kubeconfig=.build/kubeconfig get pods -n uitsmijter NAME READY STATUS RESTARTS AGE redis-master-0 1/1 Running 0 14m redis-slave-0 1/1 Running 0 14m uitsmijter-authserver-6778757698-9b45w 1/1 Running 0 14m we have one authserver up and running.\n$ kubectl --kubeconfig=.build/kubeconfig scale --replicas=2 deployment/uitsmijter-authserver -n uitsmijter deployment.apps/uitsmijter-authserver scaled $ kubectl --kubeconfig=.build/kubeconfig get pods -n uitsmijter uitsmijter-authserver-6778757698-9b45w 1/1 Running 0 19m uitsmijter-authserver-6778757698-gs9xc 0/1 Running 0 7s You may want to add new namespaces and add your own application.\nOk, as cool as this is, running a cluster with run-cluster needs a fresh production images that takes a lot of time. Doing this is recomended when working on another application that just needs Uitsmijter. It is super unproductive if we are working on Uitsmijter itself. Changeing one line of code and building a compleate fresh release is a 1:300 ratio. Therefore, it is possible to run a cluster with a incremental build dirty version, like it is with the run command:\n$ ./tooling run-cluster --dirty Run release in local KubernetesInDocker ====================================================================================================================================================================================================================== !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! 🟠 BUILD A RELEASE WITH A DIRTY VERSION!! USE THIS FOR LOCAL TESTING ONLY ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! [...] This compiles much faster after the first run. Lets see what the /version route is showing:\ncurl -k https://uitsmijter.localhost/versions dirty Which is exacltly what we\u0026rsquo;ve seen before in the run command. The only difference between run and run-cluster --dirty is, that run starts uitsmijter in docker only, while run-cluster --dirty runs Uitsmijter in a Kubernetes environment.\nThe different in the images between run and run-cluster are, that the runtime for run does not include the binary itself. To deploy an application onto kubernetes with helm we need a runtime that has uitsmijter baked in. That is why we copy Uitsmijter only optional into the runtime in ./Deployment/Runtime.Dockerfile.\nThe pricipals of the --dirty flag should be clear now. You can apply the same thing to run e2e-tests. e2e alone will build a new release every time. e2e --dirty uses the incremental build and bake it into a runtime that is used.\n$ ./tooling.sh e2e --dirty Run all e2e tests ================================================================================ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! 🟠 BUILD A RELEASE WITH A DIRTY VERSION!! USE THIS FOR LOCAL TESTING ONLY ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Build a binary incremental ================================================================================ [+] Running 1/0 ✔ Container deployment-build-1 Created 0.0s Attaching to deployment-build-1 deployment-build-1 | Uitsmijter deployment-build-1 | ------------------------------------------------------------ deployment-build-1 | Compiling plugin PackageBuildInfoPlugin... deployment-build-1 | Building for production... deployment-build-1 | Build complete! (0.33s) deployment-build-1 exited with code 0 Aborting on container exit... [+] Stopping 1/0 ✔ Container deployment-build-1 Stopped 0.0s [...] See, the build took only 33ms. For testing multiple times, this is much better than 5 minutes.\nIn summary, the intention of the Tooling for Uitsmijter is to streamline the software development process by automating various tasks, maintaining consistency, and providing developers with a user-friendly command-line interface for efficiently building, testing, and managing the Uitsmijter project.\n","description":"Commandline Tool To Build Uitsmijter - Tooling.sh A build tool is a set of tools that automate the process of testing, compiling, assembling, and packaging source code into executable software. Build tools are an essential part of the software development lifecycle, helping developers manage the complexity of building, testing, and deploying software.\nFor Uitsmijter we build a toolchain that help developers to set up the environment to work easily with the code."},{"id":15,"href":"/providers/userloginprovider/","title":"User Login Provider","parent":"Providers","content":" User Login Provider A User Login Provider is responsible for resolving a Username and Password to a user profile if the user is valid.\nIf the credentials do not match, the provider is responsible for interpreting the error message / code and tell Uitsmijter that the user is invalid.\nAt login, Uitsmijter delegates the credentials the user provides via the login form to the user backend provider. The provider must check these credentials against its user data store (e.g. kubernetes internal server, like described in the quick start guide).\nAs all providers, the User Login Provider should be written in ECMA-Script. The user service it is requesting can be anything that accepts a http request and sends a proper response with valid status codes:\n🔗 200 for OK 🔗 401 for Unauthorized Parameters Parameter Description constructor(:credentials) A Object with two properties: username and password is passed into the init function. Methods Those methods/getters must be implemented:\nMethod Description constructor(:credentials) Initialisation method that gets the username and the password for the user in question. canLogin Getter that should indicate if the current user in context can be logged in (has valid credentials) or not userProfile Getter that should return the users profile. role Getter that should return the users role. After the constructor called commit(:obj) the two getters canLogin and userProfile must have the correct values. Before the constructor calls commit(:obj) the values to differentiate the login state have to be set for sure. That means, that you should always finish the constructor script execution with a commit(...).\nExamples:\nisLoggedIn = false; constructor(credentials) { // set class variables first this.isLoggedIn = true; // than commit at the end commit(true); } get canLogin() { return this.isLoggedIn; } Full example that fetches a cluster internal user data store to validate the credentials. The user data store accepts passwords as a sha265 hash:\nclass UserLoginProvider { isLoggedIn = false; profile = {}; role = null; constructor(credentials) { fetch(`http://checkcredentials.checkcredentials.svc.cluster.local/validate-login`, { method: \u0026#34;post\u0026#34;, body: {username: credentials.username, passwordHash: sha256(credentials.password)} }).then((result) =\u0026gt; { var subject = {}; profile = JSON.parse(result.body); if (result.code == 200) { this.isLoggedIn = true; this.role = profile.role; subject = {subject: profile.userId}; } commit(result.code, subject); }); } get canLogin() { return this.isLoggedIn; } get userProfile() { return this.profile; } get role() { return this.role; } } Optional committed subject The :obj parameter in commit(:obj) is a variadic list of parameters and may have one object included that contains an object with a subject property in it. The subject is taken to identify the user across all the systems and must be unique for that users.\nA common subject is the userid from your members\u0026rsquo; database, or another person identifier like an uuid, username or the users personal email` address. You have to take care that the subject is directly correlated to the user without any doubt. The subject reflects the \u0026ldquo;primary key\u0026rdquo; of the logged-in user.\nIf your user data source is in a SQL Database and you validate the login with a simple query like select id, username from login where username = '$user' and password ='$pass' than return the id as a subject back to Uitsmijter.\nThe object with the subject can be enriched with any other data. That data will be written to the log, but ignored for further execution. It must contain a subject property, but can contain other properties.\nExamples for valid objects: Just an ID:\n{ \u0026#34;subject\u0026#34;: 1734034 } ID with other data;\n{ \u0026#34;name\u0026#34;: \u0026#34;Lorene Ibsen\u0026#34;, \u0026#34;subject\u0026#34;: 1734034, \u0026#34;instrument\u0026#34;: \u0026#34;Piano\u0026#34; } String subject:\n{ \u0026#34;subject\u0026#34;: \u0026#34;lorene.ibsen@example.com\u0026#34; } If no subject is specified, the login name (username from the login section) is used as the subject! Since username must be unique from the start, this is a good default value, but you can override it with your your own value, e.g. an ID.\nThe position inside the variadic list is irrelevant. All other parameters will be ignored, but the first one with a subject parameter will be evaluated and overwrite the subject of the JWT issued.\nExample of valid commitments:\ncommit({subject: \u0026#34;lorene.ibsen@example.com\u0026#34;}) commit(true, {subject: \u0026#34;lorene.ibsen@example.com\u0026#34;}) commit({message: \u0026#34;A good login\u0026#34;}, {\u0026#34;subject\u0026#34;: \u0026#34;lorene.ibsen@example.com\u0026#34;}, {error: false}) commit(response.status, {\u0026#34;subject\u0026#34;: \u0026#34;lorene.ibsen@example.com\u0026#34;}, {error: false}) Examples Simple Example\nThis example allows any user whose username is \u0026ldquo;frodo@example.com\u0026rdquo;. Do not use this in production!\nclass UserLoginProvider { isLoggedIn = false; constructor(credentials) { if (credentials.username == \u0026#34;frodo@example.com\u0026#34;) { // Do not use this in production! this.isLoggedIn = true; } commit({subject: \u0026#34;frodo\u0026#34;}); } // Getter get canLogin() { return this.isLoggedIn; } get userProfile() { return { name: \u0026#34;Frodo Baker\u0026#34;, species: \u0026#34;Musician\u0026#34;, }; } get role() { return \u0026#34;user\u0026#34;; } } Fetch Backend Example\nThis example allows a user log in for in every user/password combination that is known in a backend system.\nclass UserLoginProvider { isLoggedIn = false; profile = {}; constructor(credentials) { fetch(`https://example.com/users/auth`, { method: \u0026#34;post\u0026#34;, body: credentials }).then((result) =\u0026gt; { var subject = {}; profile = JSON.parse(result.body); if (result.code == 200) { this.isLoggedIn = true; subject = {subject: profile.userId}; } commit(result.code, subject); } ); } // Getter get canLogin() { return this.isLoggedIn; } get userProfile() { return profile; } get role() { return profile.role || \u0026#34;user\u0026#34;; } } Further readings User Validation Provider ","description":"User Login Provider A User Login Provider is responsible for resolving a Username and Password to a user profile if the user is valid.\nIf the credentials do not match, the provider is responsible for interpreting the error message / code and tell Uitsmijter that the user is invalid.\nAt login, Uitsmijter delegates the credentials the user provides via the login form to the user backend provider. The provider must check these credentials against its user data store (e."},{"id":16,"href":"/oauth/endpoints/","title":"Available Endpoints","parent":"OAuth","content":" Available Endpoints An endpoint is a specific location that is capable of accepting incoming requests, and is usually a specific URL (Uniform Resource Locator) that is provided by an API (Application Programming Interface). An API is a set of programming instructions and standards for accessing a web-based software application or web tool. APIs allow different software systems to communicate with each other, and enable functionality such as requesting data from a server, or sending data to a server for storage.\nOAuth (Open Authorization) is an open standard for authorization that provides a secure method for API authentication. OAuth endpoints are specific URLs that are used in the OAuth authorization process to request and grant access tokens to API resources. There are two main OAuth endpoints:\nAuthorization endpoint: This is the URL where the user is redirected to in order to grant authorization to the client application. Token endpoint: This is the URL where the client application exchanges the authorization code for an access token. In OAuth two additional endpoints should be mentioned:\nRedirection endpoint: This is the URL where the user is redirected after they grant or deny authorization to the client application. Resource endpoint: This is the URL of the API resource that the client application is trying to access. Besides the authorisation endpoint and the token endpoint Uitsmijter do provide endpoints for monitoring and metrics as well.\nThis page describes the technical details of the available endpoints and shows some basic examples how to use them. This information is importend if you are writing your own client library implementation, but you will not need to know all the details when using an already existent client library like 🔗 oidc-client-ts.\nOAuth endpoints /authorize Authorize a client to use a resource. The /authorize endpoint will redirect to a callback url with an authorization code if the user logs in successfully.\nYou can find an example setup in our quick start guide\nRecommendation:\nUse PKCE to request an authorization code.\nExample: Request an authorization code with PKCE SHA265 code\n/authorize ?response_type=code \u0026amp;client_id=9095A4F2-35B2-48B1-A325-309CA324B97E \u0026amp;redirect_uri=https://example.com/ \u0026amp;scope=read,learn \u0026amp;state=Za8uR \u0026amp;code_challenge=3VpzZL3DpqEwubIbIVsrOUbvB19kk4yGP7gGaxU/cyQ= \u0026amp;code_challenge_method=S256 Parameter description:\nParameter Description response_type Specifies the type of response that the authorization server should return. The value is code, which indicates that the authorization server should return an authorization code as the response is the only allowed option. client_id This is the unique identifier of the client application that is making the request. Read more information about client configuration. redirect_uri This is the URL that the user should be redirected to after the authorization server grant access to the client application. scope This specifies the scope of the authorization that is being requested. The value of scope is a comma-separated list of permissions that the client application is requesting access to. It have to be a subset of the allowed client-level scopes. state This is an optional parameter that can be used to pass along state information between the authorization request and the response. The state\u0026rsquo;s value will be returned by the authorisation server response. code_challenge This is an optional parameter that is used as part of the OAuth 2.0 Proof Key for Code Exchange (PKCE) extension. It represents a challenge value that is generated by the client application and sent to the authorization server as part of the authorization request. code_challenge_method Is an optional parameter that is used in conjunction with code_challenge and specifies the method that was used to generate the challenge value. In this case, the value is S256, which indicates that the challenge value was generated using the SHA-256 hash function. Possible values are: S256 or PLAIN In case the authorisation process succeeded the authorisation server responds with a redirect:\nHTTP/1.1 302 Found Location: https://example.com/?code=KJH876GFED\u0026amp;state=Za8uR This response includes the following parameters:\ncode: This is the authorization code that the client application can use to request an access token. state: This is the same state value that was included in the original authorization request. It is returned as part of the response so that the client application can verify that the response was generated in response to the correct request. This response is a 302 Found status code, which indicates that the user is being redirected to the URL specified in the Location header. In this case, the user is being redirected to the redirect_uri that was specified in the original authorization request, along with the code and state parameters.\n/token Access tokens are used for applications to perform API requests on behalf of a user. The access token represents the authorization of a specific application to access specific parts of a user’s data.\nAccess tokens must be kept confidential in transit and in storage. The only parties that should ever see the access token are the application itself, the authorization server and the resource server.\nUitsmijter implements different grant types that a client may support. For example, the authorisation code grant can be requested with a proper call to the /token endpoint and a grant type authorisation_code:\n{ \u0026#34;grant_type\u0026#34;: \u0026#34;authorization_code\u0026#34;, \u0026#34;client_id\u0026#34;: \u0026#34;9095A4F2-35B2-48B1-A325-309CA324B97E\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;read write admin_list\u0026#34;, \u0026#34;code\u0026#34;: \u0026#34;KJH876GFED\u0026#34; } For legacy applications an implicit grant flow can be turned on in the client configuration.\n{ \u0026#34;grant_type\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;client_id\u0026#34;: \u0026#34;9095A4F2-35B2-48B1-A325-309CA324B97E\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;read write admin_list\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Julia@example.com\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;eis6Ooth3oDa\u0026#34; } If the client needs to be authenticated, then a client_secret is mandatory.\nEven if the example for a password grant type is chosen, it is NOT RECOMMENDED to use this type of grant type. The ability to serve a password grant type must be enabled explicitly.\nParameter description:\nParameter Description grant_type Specifies the type of grant that is being requested. The grant type determines the flow that will be used to obtain the access token. The first example uses the authorization_code grant type, which means that the client application is requesting an access token by providing an authorization code that was previously obtained through the authorization flow. The second example uses the password grant type, which means that the client application is requesting an access token by providing the user\u0026rsquo;s login credentials (username and password). client_id Is the unique identifier of the client application that is making the request. scope This specifies the scope of the authorization that is being requested. The value of scope is a space-separated list of permissions that the client application is requesting access to. code This is the authorization code that the client application is using to request an access token. This parameter is only used in the first example (authorization_code grant type) and is not present in the second (password grant type) example. username This is the username of the user who is granting authorization to the client application. password the password of the user who is granting authorization to the client application. This parameter is only used in the password grant type. A possible response from the authorization server for the first example:\nHTTP/1.1 200 OK Content-Type: application/json { \u0026#34;access_token\u0026#34;: \u0026#34;V7vZQbJNNY7zR8IWyV7vZQbJNNY7zR8IW\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;Bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 3600, \u0026#34;scope\u0026#34;: \u0026#34;read write admin_list\u0026#34;, \u0026#34;refresh_token\u0026#34;: \u0026#34;E2yCQ4yJ0E2yCQ4yJ0\u0026#34; } This response includes the following parameters:\naccess_token: The access token that the client application can use to access the API resources. token_type: Specifies the type of the access token. In this case, the value is Bearer, which means that the access token is a bearer token and can be used to access the API resources as long as it is presented to the API server. expires_in: specifies the number of seconds until the access token expires. scope: The scope of the authorization that was granted to the client application. It should match the scope value that was included in the original request. If a client does not support all the requested scopes, an allowed subset is returned. refresh_token: A refresh token that the client application can use to obtain a new access token after the current one expires. (In the response of an authorization_code grant type request only!) The refresh_token parameter is only present in the authorization_code grant type request response, because it is only used in certain grant types. The refresh_token is used to obtain a new access token after the current one expires, without having to prompt the user for their login credentials again. That is strictly forbidden with the password grant type.\nProfile endpoints Even the /token/info endpoint is not a standard endpoint in OAuth, it is widely used to provide information about access tokens.\nTo use this endpoint, you will need to make a GET request to the /token/info endpoint and include the access token in the request. For example, you can use the curl command to make a request like this:\ncurl --request GET \\ --url https://YOUR_AUTH0_DOMAIN/token/info \\ --header \u0026#39;Authorization: Bearer YOUR_ACCESS_TOKEN\u0026#39; This will return a JSON object containing information about the access token, such as its expiration time and the scope of the authorization that it represents. For example:\n{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34; } Customise the profile:\nThe JSON object returned can be customised by the user backend provider. Everything that is returned from the userProfile getter is encoded in the JWT and will be decoded in the response of teh /token/info call.\nMonitoring endpoints Monitoring endpoints are endpoints that are used to monitor the health and status of Uitsmijter. These endpoints can be accessed via HTTP requests and return information about the current state of the system, such as its uptime, performance metrics, and login amounts as well as error counts.\nMonitoring endpoints are often used by monitoring tools to check the health of the system on a regular basis. This can help to identify potential issues or outages before they become serious problems, and can also be used to track the performance and reliability of the system over time.\nUitsmijter implements two endpoints that are ready to use for a cluster environment.\n/health Kubernetes (and other orchestration tools) uses a number of different health check mechanisms to monitor the health of various components and services. One common mechanism is to use a /health endpoint that can be accessed via an HTTP request. This endpoint is used to check the health of the component by making a request to it and examining the response.\nUitsmijter supports the /health endpoint.\nUitsmijter return a 200 OK status code if the application is healthy, or it may return a 500-status code if there is a problem. In this case the logs will have detailed information about the problem.\nKubernetes for example uses the information returned by the /health endpoint to determine the health of the authorisation server to take appropriate action if there is a problem. For example, if the /health endpoint indicates that Uitsmijter is unhealthy, Kubernetes may restart it or take other measures to try to restore it to a healthy state.\n/metrics The /metrics endpoint is an endpoint that exposes metrics data that can be collected and stored by a 🔗 Prometheus server. This endpoint can be accessed via an HTTP request (the request must include the Accept: application/openmetrics-text header) and returns a text-based format called the \u0026ldquo;Prometheus text format\u0026rdquo; that contains the metric data.\nPrometheus is a popular open-source monitoring and alerting system that is designed to collect and store metric data from various sources.\nUitsmijter provides several metrics about http request duration, error counts and logins to tenants and clients. The installation precess has a Grafana dashboard attached, that can be used to see business metrics about each tenant as well as about the overall system status over time.\nField Description http_request_duration_seconds Summary of all requested paths by method and status. http_requests_total Counters of total http requests by path, status and method. uitsmijter_login_attempts Histogram of the number of total login attempts regardless of result (success/failure). uitsmijter_login_success Counter of successful logins. uitsmijter_login_failure Counter of failed logins (wrong credentials or technical failure). uitsmijter_logout Counter of successful logout actions. uitsmijter_interceptor_success Counter of authorized accesses to pages using the interceptor middleware. uitsmijter_interceptor_failure Counter of failures trying to access pages using the interceptor middleware. uitsmijter_authorize_attempts Histogram of OAuth authorization attempts regardless of result (success/failure). uitsmijter_oauth_success Counter of successful OAuth token authorizations (all grant types). uitsmijter_oauth_failure Counter of failed OAuth token authorizations (all grant types). uitsmijter_token_stored Histogram of valid refresh tokens over time. uitsmijter_tenants_count Gauge of the current number of managed tenants. uitsmijter_clients_count Gauge containing the current number of managed clients for all tenants. Further readings Client side JWT Decoding Authorization Code Flow with Proof Key for Code Exchange ","description":"Available Endpoints An endpoint is a specific location that is capable of accepting incoming requests, and is usually a specific URL (Uniform Resource Locator) that is provided by an API (Application Programming Interface). An API is a set of programming instructions and standards for accessing a web-based software application or web tool. APIs allow different software systems to communicate with each other, and enable functionality such as requesting data from a server, or sending data to a server for storage."},{"id":17,"href":"/interceptor/examples/","title":"Example Deployment","parent":"Interceptor","content":" Interceptor Mode The interceptor mode is shown in an example deployment. The same nginx pod is accessible via two separate ingresses, one is secured by the interceptor middleware, the other is not secured.\nConfiguration To secure an ingress with the interceptor middleware you have to set an annotation to the Ingress.\nAdd this annotation to the Ingress configuration.\nannotations: traefik.ingress.kubernetes.io/router.middlewares: uitsmijter-forward-auth@kubernetescrd On an existing ingress you can add the annotation with kubectl\nkubectl patch ingress \u0026lt;my-ingress-name\u0026gt; -p \u0026#39;{\u0026#34;metadata\u0026#34;:{\u0026#34;annotations\u0026#34;:{\u0026#34;traefik.ingress.kubernetes.io/router.middlewares\u0026#34;:\u0026#34;uitsmijter-forward-auth@kubernetescrd\u0026#34;}}}\u0026#39; The resources k8s service behind the ingress is secured by the Uitsmijter middleware for 🔗 Traefik. More information about ForwardAuth middleware can be found on the 🔗 Traefik website, but you don\u0026rsquo;t have to read all of it, because Uitsmijter just uses it to grab the traffic and injects the authentication.\nInformation for the resource server If a user is logged in and the call is passed through the middleware it will be forwarded to the original called target (resource server). Besides the remitted access to the resource server the call will be enhanced by a bearerAuthorization header that holds information about the currently logged-in user. The information about the user in wrapped into a 🔗 JWT that is secured by a shared password. To decode and validate the JWT-Token you have to sync the secret that is shared by the uitsmijter namespace into your application\u0026rsquo;s namespace. The Chapter \u0026ldquo;Advanced configuration for applications behind the Interceptor-Mode\u0026rdquo; in the Interceptor Mode section provides more details about the shared secret and how to consume it.\nNote: JSON Web Key (JWK) and .well-known ist not part of Uitsmijter, yet.\nThis is an example namespace resource that syncs the secret into your namespace:\n--- apiVersion: v1 kind: Namespace metadata: name: mySecuredAppNamespace labels: jwt-secret/sync: \u0026#34;true\u0026#34; By adding the label jwt-secret/sync: \u0026quot;true\u0026quot; to the metadata section of the namespace definition, 🔗 config-syncer will create a proper secret named jwt-secret in your namespace. In that way, when you decide to rotate the JWT secret key, all applications in the cluster automatically get the new key to verify further JWT tokens.\nFurther readings detailed explained example as a walkthrough guide for securing static webserver resources. A best practise guide to migrate a monolith into microservices with Uitsmijter ","description":"Interceptor Mode The interceptor mode is shown in an example deployment. The same nginx pod is accessible via two separate ingresses, one is secured by the interceptor middleware, the other is not secured.\nConfiguration To secure an ingress with the interceptor middleware you have to set an annotation to the Ingress.\nAdd this annotation to the Ingress configuration.\nannotations: traefik.ingress.kubernetes.io/router.middlewares: uitsmijter-forward-auth@kubernetescrd On an existing ingress you can add the annotation with kubectl"},{"id":18,"href":"/general/motivation/","title":"Motivation","parent":"General","content":" Motivation Since the mid-nineties, we from aus der Technik have been dealing with the authentication and authorization of users. The conception as well as the implementation of access systems is an elementary part of our work on clients applications. For new implementations, the first choice is between the numerous existing open source or proprietary authentication systems, or the decision for or against a custom implemented solution. Not only the numerous diverse requirements count on a decision-making process, but also legal questions about user data management have to be considered individually.\nWhen creating new applications in an agile project environment, the years of experience of migrating legacy projects come into play: a too rigid system and a fixed structural formulation of user entities inhibits the later paste of the process of building features. That is not good. On the other hand, too complex authorization systems often stand in the way of a smart implementation, as numerous dependencies directly affect the business applications to be created. As a result, more time is spent on bending the user structure to fit the project requirements than on creating the optimal design for the use case. That is not good.\nCloud providers of authorization solutions that bring the user data under their responsibility give the projects a vendor lock-in that is almost impossible to leave with reasonably calculated means. OAuth as a standard was developed as an open protocol that allows standardized, secure API authorization for desktop, web and mobile applications. The current products in the SaaS market are funded precisely by hard lock-in through hosting their user entities, so they can no longer be described as truly open. That is not good. Your data should be yours. Always. Anytime.\nYou should also be able to change the authorization system at any time without having to rewrite all your applications. But to be honest, this is exactly the problem you face with the authorization products at the moment. Since the authorization systems always require the persistence of the users (or specific delegations to other difficult to influence providers of user data persistence) in their own data structures, a migration of the data from one provider to another always involves considerable effort. That is not good.\nThis major problem becomes much clearer if we look at the current project landscape of medium-sized businesses: numerous legacy applications carry an enormous amount of intellectual knowledge about the company. Applications that have grown for years are the backbone of enterprise digitization. Without a doubt, these companies must face the modernization of these applications. Decomposition into services to carry out partial modernizations, outsourcing of partial applications to the cloud for scaling and the offering of machine-to-machine communication to offer partners an integrated workflow is in full swing and will also accompany (for example us as a consultant for the modernization of applications) the next decade.\nIn order to ensure that modernization can be planned step by step, it is first essential that authorization and authentication are detached from the legacy systems and placed upstream of them. Only then partial services can be extracted and the existing application continues to be used.\nHowever, if the user data is detached from these applications, a long dependency tree is created, since these applications are usually hard-bound to fields in the user table. These dependencies have to be solved and rebuilt in such a way that external authentication is possible, accepted by the existing applications and new services can take over. Projects that do not involve a complete rewrite are difficult to implement and can rarely be completed in less than 8 months That is not good.\nTo be honest, fewer companies know about all the business implementation in all their code and \u0026ldquo;migration\u0026rdquo; means often times \u0026ldquo;rebuild and reverse engineering the requirements\u0026rdquo;. It is hard to tell the amount of time it takes and if it would be better to rewrite the most of it, rather to maintain a bunch of logic with insecure and cumbersome authentication delegates. The only way to achieve a modernisation is a B-team that sets up the \u0026ldquo;new\u0026rdquo; environment, while the \u0026ldquo;old\u0026rdquo; one must be maintained until a big-bang switch can be made. But this contradicts all processes we should work on. We have to bring business value every sprint.\nAdmittedly, we in the industry have celebrated ourselves in the past when we - or colleagues - have managed to perform migrations from monolithic applications to the cloud in half to three quarters of a year. The smart solutions were often described, shown at conferences and architects of these migrations are highly sought after employees (by the way: we also do).\nThat alone is not good. We should not be happy about it, nor proud. 80 different \u0026ldquo;Certified OpenID Provider Servers\u0026rdquo; are currently listed on 🔗 the openid website. Most of them are perfect, but all of them have the problem of trying to tell you what to do with your user data and how to handle them. All these products do not assume that user databases already exist. And that they are existing in that fashion for a good reason. They don\u0026rsquo;t nestle into the existing infrastructure and thus all cause a lot of trouble within the projects. However, the wealth of possibilities offers something for everyone. So why are we creating another Authorization Server in 2022?\nBased on the facts described, we accompanied projects that were very long, complex and expensive in their migration strategy. We saw projects that after a 2.5 year migration of user data had to go directly into the next migration because the selected SaaS provider was no longer continuing its services. That is not good. We have seen customer projects that share sessions between applications due to the fact of a migration pressure. That is not good. Projects that were offline for several days due to user migrations. That is not good. We have seen code from large companies that we would rather not have seen. That is not good. And all because we as developers were happy with difficult migrations of ~8 months. We are not anymore, because they are not good!\nUitsmijter was developed to set new standards: Authorization and authentication should be fun and an authorization server should support your daily work, instead of dictating how your business should look like. Migrating from a monolith legacy application to accept a single-sign-on token should take hours, not months. An authorization server should support you by designing new complex systems, not telling you how to do it. An authorization server has to be very fast and super reliable.\nUitsmijter is a versatile authorization server that opens up possibilities to make migrations work well. The answer to how to better support one of these has been given in every code decision - and with growing implementations we are learning and improving Uitsmijter. So much so that Uitsmijter is the ideal starting point for a new project. User authentication that is based on your requirements.\n","description":"Motivation Since the mid-nineties, we from aus der Technik have been dealing with the authentication and authorization of users. The conception as well as the implementation of access systems is an elementary part of our work on clients applications. For new implementations, the first choice is between the numerous existing open source or proprietary authentication systems, or the decision for or against a custom implemented solution. Not only the numerous diverse requirements count on a decision-making process, but also legal questions about user data management have to be considered individually."},{"id":19,"href":"/oauth/","title":"OAuth","parent":"Uitsmijter Documentation","content":" OAuth OAuth flow Grant types Available Endpoints JWT Decoding Authorization Code Flow with Proof Key for Code Exchange ","description":" OAuth OAuth flow Grant types Available Endpoints JWT Decoding Authorization Code Flow with Proof Key for Code Exchange "},{"id":20,"href":"/configuration/tenant_client_config/","title":"Tenant and client configuration","parent":"Configuration","content":" Tenant and client configuration Uitsmijter\u0026rsquo;s goal is to offer you a login solution that can be adapted to your needs in the best possible way without prescribing the architecture of the user interface, and that can be implemented extremely elegantly and quickly. In order to set up a new system with Uitsmijter or to integrate Uitsmijter into an existing system, settings are necessary that describe the desired system landscape and the surrounding environment.\nRegardless if you have a very small setup, e.g. a company with one website login, or you plan Uitsmijter for a company with multiple brands, different websites, apps and third-party clients, the setup and configuration should always be simple, easy to understand and versatile for your needs.\nConfigure one tenant with one client at least.\nTenants are seperated areas in one instance. Users, that are logged in with a client on one tenant are not logged in to the other tenant. Tenants do have a separate user backend, can have different login masks and may support different grant types.\nImagine you are the Cheese Corp. You decide to launch different tools to support your customers. For the Toast Brand you are going to provide a barkeeper app with personalized recipes. Therefore, you are using a new user database. Users that are logged in to this \u0026ldquo;tenant\u0026rdquo; should not be mixed and matched with the already existing user base of the Bread \u0026amp; Butter Club members.\nCreate an Uitsmijter instance and configure two tenants:\nBread \u0026amp; Butter Club Toast Both can have different Login masks and different origins of user data.\nClients are physical or virtual device classes that can log a user on to a tenant. If a user request a Token with one client, then this could also be used to authenticate the user with another client (called: handover). But clients can have different settings and therefore different scopes. For example a web portal should allow a user to edit (write) a profile, but does not allow that feature to an App that can only read the profile. To request a valid authorisation token a client can define constraints and redirection rules: a website may need another redirection target than an app, or a console application.\nWith the combination of a tenant with associated clients you can map the conditions of your company. Both entities should be defined as YAML-Files. See Deployment to see how to provide the tenants and clients while rollout your Uitsmijter instance.\nTenants Full example configuration (config file):\nname: bnbc config: hosts: - bnbc.example interceptor: enabled: true domain: login.bnbc.example cookie: .bnbc.example templates: access_key_id: S3AccessKeyId secret_access_key: SecretS3AccessKey bucket: uitsmijter host: https://s3.bnbc.example providers: - | class UserLoginProvider { isLoggedIn = false; profile = {}; constructor(credentials) { fetch(\u0026#34;http://provider.user.srv.cluster.local/login\u0026#34;, { method: \u0026#34;post\u0026#34;, body: { user: credentials.username, password: md5(credentials.password) } }).then((result) =\u0026gt; { console.log(\u0026#34;User Login\u0026#34;, credentials.username, r.code); if(result.status === 200){ this.isLoggedIn = true; this.profile = result.body; return commit({subject: JSON.parse(result.body).userId}); } commit(false); }); } get canLogin() { return this.isLoggedIn; } get userProfile() { return this.profile; } get role() { return this.profile.role || \u0026#34;user\u0026#34; } } - | class UserValidationProvider { isValid = false; constructor(args) { fetch(\u0026#34;http://provider.user.srv.cluster.local/is-known\u0026#34;, { method: \u0026#34;post\u0026#34;, body: { user: args.username } }).then((result) =\u0026gt; { console.log(\u0026#34;User Validation\u0026#34;, args.username, r.code); if(result.status === 200){ this.isValid = true; return commit(this.isValid); } commit(false); }); } get isValid() { return this.isValid; } } The above example configuration is for using in a Docker-Environment and in local filesystem mode. In Kubernetes change config: to spec and wrap name into metadata.\nmetadata: name: bnbc spec: hosts: # ... For local files (and docker) use config:, for Kubernetes use spec: and wrap the name into metadata. The rest is all the same.\nFor this documentation we will use the Kubernetes version only.\nThere are helpers described in the Deployment section, that do construct the YAML files from separate files located in your project folder. You may want to store your scripts in separate files and include them in the tenant configuration.\nA minimal (and most used) set of properties to describe a tenant would look like this:\nmetadata: name: bnbc spec: hosts: - bnbc.example providers: { { include ./provides/breadnbutter.js } As Kubernetes Resource If Uitsmijter run in Kubernetes the configuration of tenants have to be provided as resources within the namespace of the Uitsmijter authentication server.\napiVersion: \u0026#34;uitsmijter.io/v1\u0026#34; kind: Tenant metadata: name: bnbd-tenant spec: hosts: - bnbc.example interceptor: enabled: true domain: login.bnbc.example cookie: .bnbc.example informations: imprint_url: https://bnbc.example/imprint privacy_url: https://bnbc.example/privacy register_url: https://login.bnbc.example/register providers: - \u0026#34;class UserLoginProvider { [...] }\u0026#34; - \u0026#34;class UserValidationProvider { [...] }\u0026#34; silent_login: true Properties Property Mandatory Default Example Discussion name yes - bbnc The name of the tenant depends to your architectural discussions. Consider creating tenants for different brands or companies or teams inside your company. Remember: tenants are seperated spaces inside one instance. hosts yes - [\u0026quot;bnbc.example\u0026quot;, \u0026quot;us.bnbc.example\u0026quot;] A concrete list of hosts for which the server serves the tenant. Overlapping hosts in different tenants are not allowed, they have to be unique. Be sure that the hosts are configured as ingress hosts too. interceptor no see the full example above interceptor.enabled yes Can be set to false if the tenant should not support the Interceptor-Mode. interceptor.domain no The domain for which the interceptor should be active. interceptor.cookie no Cookie domain to be used in the auth cookie. informations no Additional data about the tenant. informations.imprint_url no https://bnbc.example/imprint URL to the imprint page. informations.privacy_url no https://bnbc.example/privacy URL to the privacy policy. informations.register_url no https://bnbc.example/register URL to the registration page. templates no not configured S3 configuration to load templatest from templates.access_key_id yes [random name] Access key ID templates.secret_access_key yes [random secret key] Secret access key / password templates.host no s3.amazonaws.com https://s3.bnbc.example S3 storage server templates.bucket yes uitsmijter S3 Bucket name templates.path no - templates/business Optional \u0026ldquo;path\u0026rdquo; inside the bucket templates.region no us-east-1 eu-central-1 S3 region (if needed) providers yes - see the full example above A list of providers. Providers are glue code only to request data from user backend systems. Consider using internal private cluster links. silent_login no true false When this option is enabled and a client has a valid auth cookie shared with the login page, its login information will be used to authenticate the user without asking for a username or password. Clients A client is an application that attempts to act on behalf of or access the user\u0026rsquo;s resources. Before a client can access a user\u0026rsquo;s account, it must obtain permission. A client obtains permission by sending the user to the authorization server and the authorization server redirects back to the client. A client can also assert permission directly with the authorization server without interaction by the user, if a previously obtained code is present.\nDefining the amount of different client depends on your needs. The list can give you a starting point:\nDo you deliver different application assets (SPA (web), App (AppStore), Shop (Web), landing page, Marketing camping, etc.) -\u0026gt; these are different Clients Do you deliver your applications to different operating systems (Android, iOS) -\u0026gt; these are different Clients Do you support different Versions of your applications with different features -\u0026gt; these are different Clients Are you allowing third parties to act with your authorisation server -\u0026gt; these are different Clients Full example configuration for configuration files\nname: bnbc-ios-app config: ident: 58392627-0121-4721-9DAC-D358BDD86CA6 tenantname: bnbc-tenant redirect_urls: - https://www.bnbc.example/bnbc-club/.* grant_types: - password - authorization_code - refresh_token scopes: - list - read - write referrers: - https://www.bnbc.example/bnbc-club/login isPkceOnly: true secret: aejochiecaishee4ootooSh3ph Remember. For Kubernetes warp name into metadata and rename config to spec:\nmetadata: name: bnbc-ios-app config: ident: 58392627-0121-4721-9DAC-D358BDD86CA6 tenantname: bnbc-tenant # [...] As Kubernetes Resource If Uitsmijter run in Kubernetes the configuration of clients have to be provided as resources within the namespace of the Uitsmijter authentication server.\napiVersion: \u0026#34;uitsmijter.io/v1\u0026#34; kind: Client metadata: name: bnbc-ios-app spec: ident: 58392627-0121-4721-9DAC-D358BDD86CA6 tenantname: \u0026#34;[tenant namespace]/bnbc-tenant\u0026#34; redirect_urls: - https://www.bnbc.example/bnbc-club/.* grant_types: - password - authorization_code - refresh_token scopes: - list - read - write referrers: - https://www.bnbc.example/bnbc-club/login isPkceOnly: true secret: aejochiecaishee4ootooSh3ph Properties Property Mandatory Default Example Discussion ident yes A random UUID 58392627-0121-4721-9DAC-D358BDD86CA6 The ident is the internal primary key for that client. name yes - bnbc-ios-app Give the client a unique and specific name. Client should be reelect the device classes that you do need to target with specific rights and get individual statistics from. tenantname yes - bnbc-tenant The name of the tenant for which this client is for. On kubernetes this must contain the tenants namespace: [tennant namespace]/bnbc-tenant redirect_urls yes - [\u0026quot;https://www.bnbc.(example\u0026amp;#124;example.com)/bnbc-club/*\u0026quot;] A client sends a redirect url to which the response will be redirected to. Specify the allowed urls for security reasons, otherwise it will be possible to hijack the token in the response. See information below. grant_types no [\u0026ldquo;authorization_code\u0026rdquo;, \u0026ldquo;refresh_token\u0026rdquo;] [\u0026quot;password\u0026quot;] A list of allowed grant types. If not set, a default set will be applied: authorization_code, refresh_token. If you need to support the “password\u0026quot; grant, you must specify it explicitly! scopes no [] [\u0026quot;recipes:read\u0026quot;, \u0026quot;recipes:write\u0026quot;, \u0026quot;timeline:post\u0026quot;] A list of allowed scopes for this client. If a client requests scopes, these will be filtered by the one that are allowed. referrers no [] [https://www.bnbc.example/bnbc-club/login] If set, only clients that come from these referers are allowed. isPkceOnly no false true If set to true this client does support Proof Key for Code Exchange only. secret no - aejochiecaishee4ootooSh3ph if set, the clients have to send this shared secret on requests. Possible Grant Types\nauthorization_code refresh_token password If you allow a authorization_code, you should also allow refresh_token, because to refresh a token you need to get one via the authorization_code request. The response from a password request does not return a refresh token!\nTry to avoid the password grant in production! It is insecure and should be replaced by a pkce code request. Only if you have to support older clients you may need to turn this option on.\nRedirect Urls If the requested redirect_url of an AuthRequest does not match any of these url patterns, the whole authorization request will be denied. Try to avoid a pattern like .*, because this is highly insecure. Try to describe the clients domains very precisely. eg: https://[^\\.]+\\.example\\.com/login_(granted|denied)\nRegular expressions are allowed to formulate redirect_urls.\nSecrets Confidential clients are clients that are able to maintain client secrecy. In general, these clients are only applications that run on a server controlled by developers and whose source code is not available to users.\nPublic clients cannot maintain a client_secret, so the secret is not used for these applications. Javascript applications are considered public clients. Since anyone running a Javascript application can easily see the source code of the application, a secret would be easily visible there.\nSet a secret for server-side applications where the user does not have access to the source code.\n","description":"Tenant and client configuration Uitsmijter\u0026rsquo;s goal is to offer you a login solution that can be adapted to your needs in the best possible way without prescribing the architecture of the user interface, and that can be implemented extremely elegantly and quickly. In order to set up a new system with Uitsmijter or to integrate Uitsmijter into an existing system, settings are necessary that describe the desired system landscape and the surrounding environment."},{"id":21,"href":"/contribution/test_cluster/","title":"Test Cluster Domains","parent":"Contribution","content":" Test Cluster Domains When running run-cluster from the Toolchain command, a bunch of test domains are set up in a local Kubernetes cluster. You can use these domains to test and evaluate Uitsmijter.\nCheese tenant example domains api.example.com This domain does not have an endpoint. This domain is used for tests and return a 404 page not found when called.\ncookbooks.example.com In cookbooks, a page served by a nginx container, you will find delicious recipes. Login is restricted via interceptor mode. Every user that ends on @example.com (like me@example.com) with any password will be granted.\nThe Cookbook is managed by the cheese tenant. The login domain is: login.example.com\ngoat.example.com The goat page is an addition the cookbooks page, and it is also part of the cheese tenant. The information about goat cheese on an Uitsmijter is restricted via interceptor mode. Since cookbooks and goat shares the same interceptor cookie domain and the same login domain (login.example.com), you are already loged on goat if you are login on cookbooks.\nBecause the goat page is managed by the same tenant as the cookbooks, every user that ends on @example.com (like me@example.com) with any password will be granted, too.\ntoast.example.com Another static page, managed by the cheese tenant and secured by interceptor mode.\nLike goat and cookbooks, every user that ends on @example.com (like me@example.com) with any password will be granted.\nspa.example.net spa is the simplest form of a single page application login. It\u0026rsquo;s for testing purpose only.\nid.example.com id.example.com is the main domain for Uitsmijter for the cheese tenant.\nIf you are logged in to one oft the pages of the tenant ( cookbooks.example.com, goat.example.com, or toast.example.com ) You can see your payload when visiting https://id.example.com Similar to this output:\nPayload: [profile: \u0026#34;[name: \u0026#34;Test User\u0026#34;]\u0026#34;, tenant: \u0026#34;cheese/cheese\u0026#34;, user: \u0026#34;me@example.com\u0026#34;, responsibility: \u0026#34;dbf0dea75e338e296e034be7b3d69aab4407771f\u0026#34;, exp: \u0026#34;1710602009.281026\u0026#34;, sub: \u0026#34;me@example.com\u0026#34;, role: \u0026#34;user\u0026#34;] If you are logged out, a login mask is presented.\nlogin.example.com This domain is used as a proxy domain for the interceptor mode of the cheese tenant. The configuration of a proxy page is described on the interceptor mode documentation page.\nWhen this page https://login.example.com is called up directly, an Uitsmijter error ERRORS.NO_TENANT is displayed, because Uitsmijter does not know which page you are trying to login for. Proxy pages can only be accessed via a referrer registered in the tenant.\nmissing-tenant.example.com The missing-tenant domain is set as a secondary ingress to login.example.com, but not registered inside the tenant configuration. Whenever you call this domain a ERRORS.NO_TENANT error should be presented.\nSo even if you pass a callee url to the missing-tenan domain, like https://missing-tenant.example.com/?for=https://goat.example.com/\u0026mode=interceptor Uitsmijter have to deny the login!\nHam tenant example domains page.ham.test On this page of the ham tenant you can read the story about Hank and Ellie. It is about an unexpected friendship. The page is served by a nginx contaienr and secured via interceptor mode.\nBecause the ham tenant turned the silen_login mode off, you are not logged in to page when you are logged in to shop.\nEvery user that ends on @example.com (like me@example.com) with any password will be granted.\nshop.ham.test Like page shop is also a static webpage served by nginx and secured via interceptor mode.\nBecause the ham tenant turned the silent_login mode off, you are not logged in to page when you are logged in to shop. You can not switch back and forth page and shop without login again, because the domain is bound to the token when silent_login is disabled.\nBecause this domain belongs to the same tenant as page.ham.test, the same login credentials (every user that ends on @example.com, like me@example.com with any password) will be granted.\napi1.ham.test This domain is only used in tests as a redirect url.\napi2.ham.test This domain is only used in tests as a redirect url.\nlogin.ham.test login.ham.test is the main domain for Uitsmijter for the ham tenant. This domain is possible not used any longer and will be removed!\nid.ham.test id.ham.com is the interceptor proxy domain to log in via Uitsmijter. Proxy domains are necessary for interceptors and described on interceptor mode documentation page.\nHam does have customized templates, so the login page will look different from the default Uitsmijter login page of the chease tenant.\nIf you are logged in to one oft the pages of the tenant (page.ham.test or shop.ham.test)\n*.s3.ham.test Internal S3-Server to store customized templates\nCredentials:\naccess_key: admin secret_key: adminSecretKey BNBC tenant example domains blog.bnbc.example This domain hosts the blog of the Bread And Butter Company. The blog is served by a nginx and secured via interceptor mode.\nEvery user that ends on @example.com (like me@example.com) with any password will be granted.\nBecause the bnbc tenant turned the silen_login mode on, you are logged in to blog if you are logged in to shop.\nshop.bnbc.example Maya and Liam (The owners of the Bread And Butter Company) does have a shop, too. The shop is served by a nginx and secured via interceptor mode.\nBecause this domain belongs to the same tenant as blog.bnbc.example, the same login credentials (every user that ends on @example.com, like me@example.com with any password) will be granted.\nThe bnbc tenant turned the silent_login mode on, so you are logged in to shop if you are already logged in to blog.\nlogin.bnbc.example login.bnbc.example is the interceptor proxy domain to log in via Uitsmijter. Proxy domains are necessary for interceptors and described on interceptor mode documentation page.\nYou can see your payload when loged in via https://login.bnbc.example/?for=https://shop.bnbc.example/\u0026amp;mode=interceptor\napi1.bnbc.example This domain is only used in tests as a redirect url.\napi2.bnbc.example This domain is only used in tests as a redirect url.\nUitsmijter tenant uitsmijter.localhost This domain is the base domain of the Uitsmijter deployment. It handles this domains:\ntest.localhost uitsmijter.localhost All users are granted.\n","description":"Test Cluster Domains When running run-cluster from the Toolchain command, a bunch of test domains are set up in a local Kubernetes cluster. You can use these domains to test and evaluate Uitsmijter.\nCheese tenant example domains api.example.com This domain does not have an endpoint. This domain is used for tests and return a 404 page not found when called.\ncookbooks.example.com In cookbooks, a page served by a nginx container, you will find delicious recipes."},{"id":22,"href":"/providers/uservalidationprovider/","title":"User Validation Provider","parent":"Providers","content":" User Validation Provider A user validation provider is responsible for checking if a Username is still valid to access the application. A user could be invalid if the user is removed from the backend user store.\nEverytime a user tries to refresh a token, the User Validation Provider will be asked if the user is still valid. The Provider will not be called on a regular login!\nAt login, Uitsmijter delegates the credentials the User Login Provider to the user backend provider. The provider must check these credentials against its user data store (e.g. kubernetes internal server, like described in the quick start guide). When a user is logged in successfully an access and a refresh token will be sent to the user. If the user exchanges the refresh token into a new access token the User Validation Provider will ask the user data store if the user is still allowed to log in.\nAs all providers, the User Validation Provider should be written in ECMA-Script. The user service it is requesting can be anything that accepts a http request and sends a proper response with valid status codes:\n🔗 200 for OK 🔗 401 for Unauthorized Parameters Parameter Description constructor(:args) A Object with one property: username is passed into the init function. Methods Those methods/getters must be implemented:\nMethod Description constructor(:args) Initialisation method that gets the username for the user in question. isValid Getter that should indicate if the current user in context can sill be logged in After the constructor called commit(:args) the getter isValid must have the correct values.\nExamples:\nisValid = false; constructor(args) { this.isValid = true; // than commit at the end commit(true); } get canLogin() { return this.isValid; } Full example that fetches a cluster internal user data store to validate the username:\nclass UserValidationProvider { isValid = false; constructor(args) { fetch(`http://checkcredentials.checkcredentials.svc.cluster.local/validate-user`, { method: \u0026#34;post\u0026#34;, body: {username: args.username} }).then((result) =\u0026gt; { if (result.code == 200) { this.isValid = true; } commit(this.isValid); }); } get isValif() { return this.isValid; } } ","description":"User Validation Provider A user validation provider is responsible for checking if a Username is still valid to access the application. A user could be invalid if the user is removed from the backend user store.\nEverytime a user tries to refresh a token, the User Validation Provider will be asked if the user is still valid. The Provider will not be called on a regular login!\nAt login, Uitsmijter delegates the credentials the User Login Provider to the user backend provider."},{"id":23,"href":"/contribution/guidelines/","title":"Development guidelines","parent":"Contribution","content":" Development guidelines Pull requests are very much desired Please open a new branch with the naming scheme feature/\u0026lt;#Issue\u0026gt;-\u0026lt;#Description\u0026gt; or fix/\u0026lt;#Issue\u0026gt;-\u0026lt;#Description\u0026gt; regarding the type of the change. Do a descriptive pull request against the main branch. Prepare the pull request; we prefer small requests, that are squashed into the main branch.\nPull request on an open issue have higher priorities, because every pull request should be inclusive and everyone in the community should be enabled to talk about the changes. So it is highly recommend to open an issue first, before starting development.\nCheck the release with ./tooling.sh tooling.sh as it runs a pipeline-like check on your local environment.\nLinting Use swiftlint (best in your IDE while saving) to lint the code before committing it. tooling.sh has a lint option that lists all errors end warnings that should have been fixed before committing the pull request.\nRequirements Pipelines must succeed\nThe CI will test the project first for a list of requirements:\nA zero warning state is desirable All tests must pass A sufficient code coverage is required Find Friends A pull request has to be approved by at least one other person.\nAll threads must be resolved Code comments are highly recommended. Be precise in your critique rather than polite. Both is most welcome.\nLeftovers and temporary code Do not merge code that contains sources that are unused and leftovers.\nContributions When contributing to this repository, please first discuss the change you wish to make via an issue.\nPlease note we have a code of conduct, please follow it in all your interactions with the project.\nYou have to agree to the Developer Certificate of Origin!\nTrunk-based Development We are using Trunk-based Development. Do always a feature-branch for your commit and open a merge request back into the main branch when you are absolutely sure that it works. Ask another member of the team if you are not sure about it.\nPull Request Process Ensure any install or build dependencies that aren\u0026rsquo;t covered by the tooling.sh script are removed before committing the pull request. Update the CHANGELOG.md with details of changes to functionality and to all interfaces, this includes new environment variables, exposed ports, useful file locations and container parameters. Let other people review your merge request and add suggestions made by the community into your code. Further readings Our code of conduct ","description":"Development guidelines Pull requests are very much desired Please open a new branch with the naming scheme feature/\u0026lt;#Issue\u0026gt;-\u0026lt;#Description\u0026gt; or fix/\u0026lt;#Issue\u0026gt;-\u0026lt;#Description\u0026gt; regarding the type of the change. Do a descriptive pull request against the main branch. Prepare the pull request; we prefer small requests, that are squashed into the main branch.\nPull request on an open issue have higher priorities, because every pull request should be inclusive and everyone in the community should be enabled to talk about the changes."},{"id":24,"href":"/interceptor/","title":"Interceptor","parent":"Uitsmijter Documentation","content":" Interceptor Walkthrough Guide Interceptor Mode Example Deployment Migrating a monolith application ","description":" Interceptor Walkthrough Guide Interceptor Mode Example Deployment Migrating a monolith application "},{"id":25,"href":"/oauth/jwt_decoding/","title":"JWT Decoding","parent":"OAuth","content":" JWT Decoding OAuth does not have a specific standard \u0026ldquo;profile endpoint\u0026rdquo; for decoding the content of a JSON Web Token (JWT). OAuth is a standard for authorization, which means that it is primarily concerned with granting and revoking access to resources, rather than with providing information about the user who is accessing the resources. But certain libraries (like oidc-client-ts) expecting it for decoding a profile content, so Uitsmijter supports a decoding endpoint for valid and non expired tokens at GET /token/info. See more details at the endpoint documentation.\nThat being said, it is common for OAuth servers to include information about the user in the JWT that is issued as part of the authorization process. This information is typically encoded in the \u0026ldquo;claims\u0026rdquo; of the JWT, and can include the user\u0026rsquo;s internal id, name, username, email address, and other details.\nTo decode the content of a JWT, you can use a library or tool that is capable of parsing and verifying JWTs. There are many such libraries and tools available, and they typically provide functions or APIs that you can use to decode the JWT and access the claims contained within it.\nFor example, in the Node.js runtime environment, you can use the 🔗 jsonwebtoken library to decode a JWT and access its claims like this:\nconst jwt = require(\u0026#39;jsonwebtoken\u0026#39;); const token = \u0026#39;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\u0026#39;; const decoded = jwt.verify(token, secret); console.log(decoded); This will decode the JWT and output the claims contained within it to the console. You can then access the individual claims using the dot notation, like this:\nconsole.log(decoded.name); // \u0026#34;John Doe\u0026#34; Further readings Authorization Code Flow with Proof Key for Code Exchange ","description":"JWT Decoding OAuth does not have a specific standard \u0026ldquo;profile endpoint\u0026rdquo; for decoding the content of a JSON Web Token (JWT). OAuth is a standard for authorization, which means that it is primarily concerned with granting and revoking access to resources, rather than with providing information about the user who is accessing the resources. But certain libraries (like oidc-client-ts) expecting it for decoding a profile content, so Uitsmijter supports a decoding endpoint for valid and non expired tokens at GET /token/info."},{"id":26,"href":"/configuration/logging/","title":"Logging","parent":"Configuration","content":" Logging The Uitsmijter authorisation server logs in different levels and formats. As default, it logs in INFO and plain strings onto the console but ndjson format is also supported.\nThe default might change in the future because ndjson is more commonly used.\nSetting the level The following levels are available:\nName Description trace Appropriate for messages that contain information normally of use only when tracing the execution of a program. debug Appropriate for messages that contain information normally of use only when debugging a program. info Appropriate for informational messages. notice Appropriate for conditions that are not error conditions, but that may require special handling. warning Appropriate for messages that are not error conditions, but more severe than notice. error Appropriate for error conditions. critical Appropriate for critical error conditions that usually require immediate attention. Set the LOG_LEVEL as an environment variable to get the logs of the level of detail you need.\nIf you run Uitsmijter in local development mode, you can set the environment variable LOG_LEVEL in the file .env.\nLOG_LEVEL=debug Installing on Kubernetes via Helm you set the environment variable in a Values.yaml. Please have a look at the deployment documentation\nSetting the format Those formats are available\nName Description console Logs a plain log string in the format of [ level ] Message. ndjson Logs detailed information as a one line json string. Set the LOG_FORMAT as environment variable to log in the needed form.\nIf you run Uitsmijter in local development mode, you can set the environment variable LOG_LEVEL in the file .env.\nLOG_LEVEL=debug Installing on Kubernetes via Helm you set the environment variable in a Values.yaml. Please have a look at the deployment documentation and the quick start guide.\n","description":"Logging The Uitsmijter authorisation server logs in different levels and formats. As default, it logs in INFO and plain strings onto the console but ndjson format is also supported.\nThe default might change in the future because ndjson is more commonly used.\nSetting the level The following levels are available:\nName Description trace Appropriate for messages that contain information normally of use only when tracing the execution of a program."},{"id":27,"href":"/interceptor/migrating_monolith/","title":"Migrating a monolith","parent":"Interceptor","content":" Migrating a monolith application into microservices with single sign on Page navigation:\nGeneral Discussion Facing the problems of an application migration path The Demo-Project used for this documentation Configuring Uitsmijter checkcredentials Proxy Service Changes that need to be made You have made it! General Discussion Articles Available Please checkout our article that discuss the general thoughts behind agile migration. Facing the problems of an application migration path Monolithic applications with their own login have one or more of the following factors in common:\nown, per application different kinds, of user authentication user data is stored in the applications database users usually have an internal ID, generated by the database (auto-increment) With this ID further fields from other database tables are linked This results in the problem that removing the user authentication would entail a complete redesign of the application. Moreover, many authentication systems demand the migration of user data to their dedicated user repositories, complete with their unique sets of rights, roles, and profiles. These can be substantially different from the existing database structures. When transitioning from an internal login system to OAuth, not only does the user handle change, but it also triggers alterations within the internal structures of the application and impacts all database connections. However, with Uitsmijter, these challenges can be circumvented. We will now explore a straightforward method for achieving this.\nTo enable the conversion of monolithic applications, which originally have their own login systems, to process an SSO handle from external sources, users typically need to be migrated to an external system for most procedures. Traditionally, this migration process involved several test runs, often conducted during batch processing at night, especially when the implementation was not yet complete. Subsequently, the old application had to be entirely replaced by the new implementation in a single significant transition (Big Bang). Unfortunately, this approach frequently resulted in errors and application failures. However, with Uitsmijter, the transition of an application can be achieved progressively and while it\u0026rsquo;s in operation, all without any downtime. We\u0026rsquo;ll delve into how this works shortly.\nPreviously, when monolithic applications shifted from custom login systems to OAuth, they had to grapple with the complexities of OAuth in its entirety. This conversion was—and still is—a monumental task that consumes considerable time and resources. However, we\u0026rsquo;re about to unveil how Uitsmijter can simplify this process dramatically, making it an ideal fit for modern, Sprint-based development methodologies.\nWhen all these issues are combined (and so far, we\u0026rsquo;ve only discussed user-related concerns), it leads to a prolonged, perilous, and intricate migration process. Many companies hesitate to undertake this migration, thereby delaying their transition to a microservices architecture—a change that could significantly boost productivity for the vast majority of organizations. Uitsmijter offers a solution—a software and accompanying guides that make migration secure, well-planned, agile, and, most importantly, enjoyable for developers and project owners. Its transparent and intelligent approach makes it a standout choice for navigating the complexities of this transformation.\nPrepare an Interceptor first The Interceptor mode of Uitsmijter is primarily designed to secure individual web pages behind a login. Many users employ this mode to protect HTML pages (for instance, within an intranet or a closed client area) or to implement metering and a paywall to monetize editorial content.\nWhile the Interceptor mode is well-suited for these purposes, it possesses features that can significantly aid us in the migration process and should not be underestimated in terms of its capabilities.\nInternally, Uitsmijter employs the same mechanisms and externally presents two modes: OAuth and Interceptor. Internally, it is essentially the same, and an application protected through an Interceptor can easily be secured with an OAuth client. An application whose authentication is protected via the Interceptor mode can be enhanced by OAuth microservices that also recognize the user (SSO). This is precisely what we aim to achieve during the migration process: initially, we transition the monolith\u0026rsquo;s login, allowing us to gradually extract individual parts of the application as microservices.\nBy following this approach, we can break down the entire migration into manageable units, modernizing the infrastructure step by step. Moreover, with each iteration, we can continue to work on additional features. No Big Bang, no risks, no downtime.\nAs described, the simple Interceptor mode is indeed the ideal initial step to authenticate users through Uitsmijter before we proceed to externalize specific aspects.\nThe Demo-Project used for this documentation To keep things simple, we use an easy ToDo-App to explain what is needed to migrate from a monolith to a microservice architecture with Uitsmijter.\nThe following simple database setup is given to demonstrate the migration: things Table Description failed_jobs Internal from the 🔗Laravel framework this legacy application is build upon. Queues in Laravel stores failed asynchronous job into the table. migrations 🔗 Laravel provides database agnostic support for creating and manipulating tables across all supported database systems. The table stores the state of the database. users All users are stored in this table along a encrypted password and the email address of the user. sessions This application is a legacy monolith with its own user login. The active logins are stored in server sessions and be tracked in this database. 1 password_resets Laravel provides convenient services for sending password reset links and secure resetting passwords. todos For demonstartion purpose the application handels todo actions that are stored in this table. A foreign key to the users table links the user who created the task. 1: This tutorial assumes that your monolithic application runs already on 🔗 Kubernetes. To run multiple pods of the application be sure that sessions are stored in database or other shared storage and not on the filesystem.\nThe application itself is very basic and a straight forward. It is a Laravel application written in PHP. You can find and download the ToDo App on this GitHub Repository.\nThe application provides a simple login page. After a user successfully logs in, a list of tasks is displayed. Each task has a description and the user who created this task is shown right beside the task. The authorised user can create new tasks and mark others as completed.\nAdmittedly, this is a very simple application, but it has an obvious problem that must be taken into account if the logout is not going to be part of the application itself in the future: All tasks in the todos table are linked to the users table. If the user table should be pulled out in the future, the link that is made with a foreign key must be replaced by something else.\nAnother problem could be that when this todo-list should also be accessible via a mobile app, the session can\u0026rsquo;t be used when it turns to a stateless server.\nLet\u0026rsquo;s dive into the code and understand how the login is made:\nAuthenticatedSessionController.php have three methods:\ncreate: This method is called by a GET request to /login. it displays the login page. public function create() { return view(\u0026#39;auth.login\u0026#39;); } store: Handle an incoming authentication request. by a POST request from the login form. public function store(LoginRequest $request) { $request-\u0026gt;authenticate(); $request-\u0026gt;session()-\u0026gt;regenerate(); return redirect()-\u0026gt;intended(RouteServiceProvider::HOME); } First the authenticate() method is called to authenticate the user. The authenticate method in LoginRequest.php checks the email and the password against the database. If this does not match, an error is returned.\nThe user session will be generated and at the end the request is redirected to the HOME, the page that shows the task list.\ndestroy: Destroy an authenticated session when the user logout. The TodoController.php is as simple as the login controller:\nstore: Creates a new ToDo item update: Updates the provided ToDo task Configuring Uitsmijter To migrate this ToDo-Application to be used with a Single-Sign-On with Uitsmijter the first step is to create a Tenant with enabled interceptor mode.\nCreate a Tenant:\n--- apiVersion: \u0026#34;uitsmijter.io/v1\u0026#34; kind: Tenant metadata: name: Tasks namespace: todo-application spec: hosts: - todo.example.com interceptor: enabled: true domain: todo.example.com cookie: .example.com providers: - | class UserLoginProvider { auth = false; constructor(credentials) { this.auth = false; commit(this.auth); } get canLogin() { return this.auth; } get userProfile() { return { name: \u0026#34;No User\u0026#34; }; } get role() { return \u0026#34;user\u0026#34;; } } - | class UserValidationProvider { valid = false; constructor(args) { this.valid = false; commit(this.valid); } get isValid() { return this.valid; } } All details for tenant configuration are bespoken in Tenant and client configuration. For now, we accept this basic configuration, because we do not need any further settings.\nThe most important section in the tenant-yaml is the providers section. In this first configuration this.auth is set to false, because no user should be able to log in yet.\nAt first, we want to leave the user data in the application database. To connect the uitsmijter tenant with the database we have to write the first microservice that acts as a proxy.\nBe sure that your database credentials of the ToDo-Application is stored in a configmap or a secret. If the application is already running on Kubernetes this is mostly the case. We will use the same configmap or secret to configure the proxy-service to the user database.\nAt this point there are two options how a user database could be configured:\nAn Api-Route in the existing Application to verify user credentials An extra proxy-service to the database table You should always consider using option two! This is because we want to be able to composite our services more and if we build the route to our existing legacy application we will never be able to pull things out in the future.\nThe next chapter describes the proxy service in detail, but first lets configure a uitsmijter tenant. We do not need a Client for the interceptor mode, yet.\nThe Tenant for the ToDo application:\n--- apiVersion: \u0026#34;uitsmijter.io/v1\u0026#34; kind: Tenant metadata: name: Tasks namespace: todo-application spec: hosts: - todo.example.com interceptor: enabled: true domain: todo.example.com cookie: .example.com providers: - | class UserLoginProvider { isLoggedIn = false; profile = {}; role = null; constructor(credentials) { fetch(`http://checkcredentials.todo-application.svc/validate-login`, { method: \u0026#34;post\u0026#34;, body: { username: credentials.username, passwordHash: credentials.password } }).then((result) =\u0026gt; { var subject = {}; this.profile = JSON.parse(result.body); if (result.code == 200) { this.isLoggedIn = true; this.role = profile.role; subject = {subject: this.profile.userId}; } commit(result.code, subject); }); } get canLogin() { return this.isLoggedIn; } get userProfile() { return this.profile; } get role() { return this.role; } } - | class UserValidationProvider { isValid = false; constructor(args) { fetch(`checkcredentials.todo-application.svc/validate-user`, { method: \u0026#34;post\u0026#34;, body: { username: args.username, } }).then((result) =\u0026gt; { response = JSON.parse(result.body); if (result.code == 200 \u0026amp;\u0026amp; response.isDeleted === false) { this.isValid = true; } commit(this.isValid); }); } get isValid() { return this.isValid; } } The little ECMA-Scripts in the tenant providers do the following:\nhttp://checkcredentials.todo-application.svc/validate-login is called with username and the user password. See hashing options on the providers page. this would than look like this:\nfetch(`http://checkcredentials.todo-application.svc/validate-login`, { method: \u0026#34;post\u0026#34;, body: { username: credentials.username, passwordHash: sha256(credentials.password) } }) If the HTTP status code is OK, than the user is logged in.\nThe returned object is treated as the users profile that includes a role and a userId.\nThe userId is important and have to be unique for all users. The userId is the main handle to identify the user. In the case of this demo application it must be the user-id from the database! We do have the flexibility to extend this later on, but for now the best use case is to stick to the primary key from the legacy database.\nThere is a problem in UserLoginProvider: the password is not hashed! This is because the ToDo application stores the passwords in Bcrypt. There is no Bcrypt hashing available in uitsmijter yet (Checkout the roadmap for further information). But even when Bcrypt is available, we can not hash the password here, because Bcrypt\u0026rsquo;ed passwords can not be compared with each other like sha265-hashes. This is because Bcrypt uses a unique salt for each password hash, so even if two users have the same password, their Bcrypt hashes will be different due to the different salts. This makes it impossible to compare them directly. Bcrypt also incorporates a work factor, which is a parameter that determines how computationally intensive the hashing process is. This work factor can be adjusted, and it\u0026rsquo;s typically set high to make it time-consuming and resource-intensive for attackers to compute hash values. As a result, hashing the same password multiple times will yield different results because the salt and work factor are different.\nThe proxy service must receive the plaintext password and match it with the Bcrypt hash in the database.\nFor security reasons, make sure that you never expose the proxy service to the outside world. Make sure you have encrypted internal connections in Kubernetes.\nThat\u0026rsquo;s all Uitsmijter needs to work properly and provide a login mechanism for the ToDo application.\nBut wait\u0026hellip; A service called checkcredentials needs to be created to act between Uitsmijter and the Users table.\ncheckcredentials Proxy Service In this GitHub-Repository is a very simple example written in TypeScript upon the Koa-Framework. Let\u0026rsquo;s walk through the functions:\nA Credentials interface accepts the request from the fetch method of the tenant provider.\nexport interface Credentials { username: string; password?: string; } Two routes are used by provider scripts: validate-login to check the user credentials and validate-user to check if the user is still valid.\nrouter.post(\u0026#39;/validate-login\u0026#39;, validateLoginController); router.post(\u0026#39;/validate-user\u0026#39;, validateUserController); validate-user is straight forward and just checks if the user is still present in the database:\nexport const validateUserController: Middleware = async (ctx) =\u0026gt; { const body: Credentials = ctx.request.body as Credentials; if (body.username === undefined || body.username.length \u0026lt;= 0) { ctx.throw(StatusCodes.NOT_ACCEPTABLE, \u0026#39;missing username\u0026#39;); } const user = await prisma.users.findFirst({ where: {email: body.username}, }); if (user) { ctx.body = \u0026#39;\u0026#39;; ctx.status = StatusCodes.OK; return; } ctx.status = StatusCodes.NOT_FOUND; }; If the user is present the funttion returns a status code 200, if not than a 404 is returned.\nIn the validate-login function the password must be compared with the received password:\nexport const validateLoginController: Middleware = async (ctx) =\u0026gt; { const body: Credentials = ctx.request.body as Credentials; if (body.username === undefined || body.username.length \u0026lt;= 0 || body.password === undefined || body.password.length \u0026lt;= 0) { ctx.throw(StatusCodes.NOT_ACCEPTABLE, \u0026#39;missing credentials\u0026#39;); } const user = await prisma.users.findFirst({ where: {email: body.username}, }); if (user) { const valid = await compare(body.password!, user.password); if (valid === true) { ctx.body = JSON.parse( JSON.stringify( user, (key, value) =\u0026gt; (typeof value === \u0026#39;bigint\u0026#39; ? value.toString() : value), ), ); ctx.status = StatusCodes.OK; return; } ctx.status = StatusCodes.UNAUTHORIZED; return; } ctx.status = StatusCodes.NOT_FOUND; }; compare(body.password!, user.password); comes from Bcrypt library.\nEnough coding. To access the service inside Kubernetes a service must be applied:\n--- kind: Service apiVersion: v1 metadata: name: checkcredentials namespace: todo-application spec: selector: app: checkcredentials ports: - protocol: TCP port: 80 targetPort: 3000 When this application is deployed to Kubernetes the service is accessible internally via http://\u0026lt;service\u0026gt;.\u0026lt;namespace\u0026gt;.svc = checkcredentials.todo-application.svc.\nWarning Do not create an ingress to this service. This should be accessible privately inside the cluster, only!\nThis tutorial assumes that you are familiar with Kubernetes Deployments and you are able to deploy an application. See this repository to get an example you can use.\nChanges that need to be made Back to the PHP ToDo application, the user authentication needs to be changed to parse and decode a JWT instead of checking the user credentials against the database.\nTo make the migration easier, we will be using php-open-source-saver/jwt-auth to handle the JWT parsing.\nFirst we have to extend the web middleware group in app/Http/Kernel.php to contain 'jwt.auth' so that the JWT will be interpretet on every request.\nprotected $middlewareGroups = [ \u0026#39;web\u0026#39; =\u0026gt; [ \u0026#39;jwt.auth\u0026#39;, \\App\\Http\\Middleware\\EncryptCookies::class, // [...] ], // [...] ]; Then we need a JWTAuthProvider which handles the user management by loading the existing user when it exists.\nclass JWTAuthProvider extends JWTAuthIlluminate { /** * @param mixed $id * @return bool */ public function byId($id) { /** @var $user */ $user = User::whereEmail($id)-\u0026gt;first(); if (!$user) { return false; } // Log in the user for the request $this-\u0026gt;auth-\u0026gt;setUser($user); // User is authorized return true; } } To further prepare the application for the time when the available users are managed by another micro service completely, we can extend it to create users on the fly when they don\u0026rsquo;t exist yet. For that we extend the previously implemented user check to create a user in the application database instead of returning false which would abort the request:\nif (!$user) { /** @var JWTAuth $auth */ $auth = app(\u0026#39;tymon.jwt.auth\u0026#39;); // Load payload data $payload = $auth-\u0026gt;getPayload(); // Create user (new User([ \u0026#39;email\u0026#39; =\u0026gt; $payload-\u0026gt;get(\u0026#39;sub\u0026#39;), \u0026#39;name\u0026#39; =\u0026gt; $payload-\u0026gt;get(\u0026#39;profile\u0026#39;)[\u0026#39;name\u0026#39;], \u0026#39;password\u0026#39; =\u0026gt; \u0026#39;\u0026#39; ]))-\u0026gt;save(); // Load created users data $user = User::whereEmail($id)-\u0026gt;first(); } This auth provider can now be configured in config/jwt.php (which can be generated by running php artisan vendor:publish --provider=\u0026quot;PHPOpenSourceSaver\\JWTAuth\\Providers\\LaravelServiceProvider\u0026quot;) by overwriting the providers.auth setting:\n\u0026#39;providers\u0026#39; =\u0026gt; [ // [...] \u0026#39;auth\u0026#39; =\u0026gt; App\\Http\\Helpers\\JWTAuthProvider::class, // [...] ], It needes the JWT_SECRET configured in the environment (which is Uitsmijters jwtSecret shared secret), for example in the projects .env file.\nTo support logout, the AuthenticatedSessionController::destroy method must be extended to use the jwt auth guard and redirect to the Uitsmijter servers /logout endpoint with the right client_id to properly end the session there.\nThat guard has to be configured in config/auth.php by extending the guards list:\n\u0026#39;guards\u0026#39; =\u0026gt; [ // [...] \u0026#39;jwt\u0026#39; =\u0026gt; [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;jwt\u0026#39;, \u0026#39;provider\u0026#39; =\u0026gt; \u0026#39;users\u0026#39;, ], ], To make the user data rertrieval a bit easier, we should also change the users primary key to its e-mail address by setting protected $primaryKey = 'email'; and implementing the JWTSubject interface which can be done by adding the following methods:\npublic function getJWTIdentifier() { return \u0026#39;email\u0026#39;; } public function getJWTCustomClaims() { return []; } This has the side-effect that queries which previously implicitly detect the reference keys must be explicitly set to users.id. In this case that can be done by updating the Todo models user() method:\nreturn $this-\u0026gt;belongsTo(User::class, \u0026#39;user_id\u0026#39;, \u0026#39;id\u0026#39;); Last, when the application is deployed using Kubernetes, its Ingress must be extended to manage the user authentication by adding the annotation traefik.ingress.kubernetes.io/router.middlewares: uitsmijter-forward-auth@kubernetescrd where uitsmijter is the namespace of Uitsmijter and forward-auth the middleware name to forward the authentication handling.\nYou have made it Congratulations! A monolithic application with its own login has been transformed into an OAuth application. Now you can use the same OAuth sessions for other clients and start pulling out features or attaching new features as microservices.\n","description":"Migrating a monolith application into microservices with single sign on Page navigation:\nGeneral Discussion Facing the problems of an application migration path The Demo-Project used for this documentation Configuring Uitsmijter checkcredentials Proxy Service Changes that need to be made You have made it! General Discussion Articles Available Please checkout our article that discuss the general thoughts behind agile migration. Facing the problems of an application migration path Monolithic applications with their own login have one or more of the following factors in common:"},{"id":28,"href":"/general/requirements/","title":"Requirements","parent":"General","content":" Requirements Kubernetes This application is mainly meant to run on Kubernetes (K8s) and protect resources that run on Kubernetes clusters. Uitsmijter is tested on Kubernetes version 1.22.0 and above.\nMust have preinstalled resources 🔗 Traefik in version \u0026gt;= 2.9 Currently the Interceptor Mode is only available for Traefik at the moment. If you are using other ingress controllers, please feel free to contact us. We are constantly working on new features and integrations.\nAttention: You have to enable allowExternalNameServices in Traefik! See 🔗 this Traefik documentation to set up Traefik correctly.\nSettings in Traefik deployment\n- --providers.kubernetesingress.allowExternalNameServices=true 🔗 Helm in version \u0026gt; 3.0 We provide a setup routine in Helm Charts that installs Uitsmijter onto Kubernetes with all necessary resources. Read more about the installation process in the quick start tutorial.\n🔗 Cert-Manager Valid certificates are a must-have for a secure login. We recommend to use cert-manager to get valid 🔗 Let’s Encrypt certificates for your cluster ingresses.\nOptional but recommended resources 🔗 config-syncer The authorization server signs the JWT with a secret that every client must know. Rather than storing various secrets in different namespaces that are hard to keep in sync we recommend to use config-syncer to distribute the one secret to every namespace that is allowed to consume the secret.\n🔗 Prometheus Uitsmijter does not have its own management portal because it is not necessary and would brand the product. For the sake of simplicity and fully respect of your workflow everything can be configured as declarative code in 🔗 custom resources and 🔗 configmaps. To see what is Uitsmijter doing, it provides a wide set of metrics data in the 🔗 OpenMetrics format. We recommend to use Prometheus to collect the metrics.\n🔗 Grafana Because of the absence of an administrative portal that would dictate you how to take a look on the metrics, Uitsmijter offers a wide range of OpenMetrics data. To show them in meaningfully graphs a Grafana Dashboard is provided. You may want to use the dashboard as a starting point and bring in your own business metrics.\nDocker It is possible to run Uitsmijter in a docker environment for production. Unfortunately this operational mode is not documented yet.\nMust have preinstalled resources 🔗 Docker in version 20.10 🔗 Docker Compose in version 2.13.0 🔗 Traefik in version \u0026gt;= 2.9 If you are using docker or some other kind of orchestration please feel free to contact us. We are open to share some information and can help to implement Uitsmijter in a different setup than Kubernetes.\nFurther readings Quick Start Guide for Kubernetes. ","description":"Requirements Kubernetes This application is mainly meant to run on Kubernetes (K8s) and protect resources that run on Kubernetes clusters. Uitsmijter is tested on Kubernetes version 1.22.0 and above.\nMust have preinstalled resources 🔗 Traefik in version \u0026gt;= 2.9 Currently the Interceptor Mode is only available for Traefik at the moment. If you are using other ingress controllers, please feel free to contact us. We are constantly working on new features and integrations."},{"id":29,"href":"/contribution/goals/","title":"Overall Goals","parent":"Contribution","content":" Overall Project Goals The overall project goals encompass a range of objectives that go beyond the functional requirements of the system. These goals primarily focus on the non-functional aspects, aiming to ensure the system\u0026rsquo;s performance, reliability, security, and usability. By considering these non-functional requirements, the project aims to deliver a robust and user-friendly solution that meets the standards of quality and user satisfaction.\nEase Of Use: One of the key non-functional requirements of the project is the ease of use. The system should be intuitive and user-friendly, catering to users of varying technical expertise. By focusing on usability, the project aims to minimize the learning curve and enable users to configure and interact with the system effortlessly. This includes providing clear and concise instructions, intuitive log messages, and logical workflows. The system should be designed with a user-centric approach, considering factors such as readability, accessibility, and consistency in design. By prioritizing ease of use, the project seeks to enhance user satisfaction, encourage adoption, and facilitate efficient utilization of the system\u0026rsquo;s functionalities.\nRules to ensure To configure a feature it must be clearly named and their name must say what the setting does Less configuration is preferred over complex alternatives Log messages should say a) what happens and b) why it happens and c) what the user can do to fix it Security Another crucial non-functional requirement is security. The system should be designed with robust security measures to protect sensitive data and prevent unauthorized access. This includes implementing software with security-first mindset. One reason why we choose Swift as a language is that Swift has been designed with a strong emphasis on memory safety. It implements automatic memory management through ARC (Automatic Reference Counting), reducing the risk of common memory-related vulnerabilities such as buffer overflows, dangling pointers, and memory leaks. Do not work around it! Prefer immutable types and immutable variables. The project aims to ensure the confidentiality, integrity, and availability of the system and its data, safeguarding against potential security breaches and vulnerabilities. By prioritizing security, the project seeks to establish trust and confidence among users, promoting the adoption and continued usage of the system.\nRules to ensure Use Swift\u0026rsquo;s standard library that provides security-focused components, such as cryptographic APIs, which are essential for secure development. It includes support for common cryptographic operations like hashing, encryption, and secure random number generation. The availability of these built-in security features reduces the need for external libraries. Use modern Syntax and Features: Swift incorporates modern programming language features that contribute to safer coding practices. It includes features like strong type inference, pattern matching, and safer error handling with the \u0026ldquo;try-catch\u0026rdquo; mechanism. These features encourage developers to write more robust and secure code by minimizing common sources of bugs and vulnerabilities. Adapt language improvements early. Do not bleed any user relevant information to console or logs. Performance Furthermore, performance is a vital non-functional requirement for the project. The system should be designed and optimized to deliver exceptional speed and responsiveness, ensuring that users can log in efficiently without experiencing any significant delays or performance bottlenecks. Even so, the developer and administrator of an Uitsmijter instance should to the work without performance bottlenecks. This includes efficient data processing, quick response times for user interactions, and minimal system downtime. By prioritizing performance, the project aims to create a seamless user experience that maximizes productivity and minimizes frustration. A high-performing system will not only enhance user satisfaction but also increase the overall efficiency and effectiveness of the tasks performed within the system.\nRules to ensure Choose appropriate algorithms and data structures that are efficient for the specific problem Minimize I/O Operations: Minimize disk I/O, network requests, and file operations whenever possible. Utilize asynchronous programming techniques to handle time-consuming tasks in a non-blocking manner. Conduct regular performance testing and profiling to identify performance bottlenecks. ","description":"Overall Project Goals The overall project goals encompass a range of objectives that go beyond the functional requirements of the system. These goals primarily focus on the non-functional aspects, aiming to ensure the system\u0026rsquo;s performance, reliability, security, and usability. By considering these non-functional requirements, the project aims to deliver a robust and user-friendly solution that meets the standards of quality and user satisfaction.\nEase Of Use: One of the key non-functional requirements of the project is the ease of use."},{"id":30,"href":"/oauth/pkce/","title":"PKCE","parent":"OAuth","content":" Authorization Code Flow with Proof Key for Code Exchange The Authorization Code Flow with Proof Key for Code Exchange (PKCE) is an OAuth 2.0 flow that is used to secure the authorization process in native applications and single-page applications (SPAs). It is an extension to the standard authorization code flow, and it adds a step that helps to prevent authorization code interception attacks.\nA description of the authorization code flow with PKCE:\nThe client application initiates the authorization process by directing the user\u0026rsquo;s browser to the authorization server. The client includes a number of parameters in the request, such as the client_id, the redirect_url, and the scope of the authorization request. The authorization server prompts the user to log in and grant authorization to the client. If the user grants authorization, the authorization server sends an authorization code to the client\u0026rsquo;s redirect URI. The client receives the authorization code and sends a request to the token endpoint to exchange the code for an access token. In this request, the client includes the authorization_code, the client_id, and the client_secret (if the client is confidential). To secure the authorization process, the client also includes a code_verifier in the request. The code verifier is a cryptographically random string that is generated by the client, and it is used to prove that the client is the same one that initiated the authorization request. The authorization server verifies the authorization_code and the code_verifier, and if they are valid, it issues an access_token to the client. The access token can then be used to access the API resources on behalf of the user. The main advantage of the authorization code flow with PKCE is that it helps to prevent authorization code interception attacks. In these attacks, an attacker tries to intercept the authorization code as it is being sent from the authorization server to the client\u0026rsquo;s redirect URI. If the attacker is successful, they can use the authorization code to obtain an access token and access the API resources on behalf of the user.\nTo prevent this from happening, the authorization code flow with PKCE adds a step in which the client generates a code verifier and sends it to the authorization server along with the authorization code. The authorization server uses the code verifier to verify that the client is the same one that initiated the authorization request, and it only issues an access token if the code verifier is valid. This helps to ensure that the authorization process is secure and that only the intended client can obtain an access token.\nIn general, it is a good idea to use PKCE whenever you are using the authorization code flow, unless you have a specific reason not to. For example if you are using a client library or framework that does not support PKCE: PKCE is a relatively new extension to OAuth 2.0, so some client libraries or frameworks might not yet support it. In this case, you would not be able to use PKCE with these libraries or frameworks. Consider to update the client library.\nClients as describes in tenant and client configuration can be set to except PKCE-only clients. This should be the default and could be the default if not set explicitly to false in the configuration of the client.\nGenerating a code verifier If not covered by the client library you use, then a code verifier can be calculated easily by your own.\nTo calculate a code verifier in the client, you can use a cryptographically secure random number generator (CSPRNG) to generate a random string of sufficient length and complexity. The code verifier should be at least 43 characters long and consist of upper and lower case letters, digits, and special characters.\nExample of how you might generate a code verifier in a JavaScript client:\nfunction generateCodeVerifier() { const charset = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~\u0026#39;; let codeVerifier = \u0026#39;\u0026#39;; for (let i = 0; i \u0026lt; 43; i++) { codeVerifier += charset[Math.floor(Math.random() * charset.length)]; } return codeVerifier; } This function uses the Math.random() function to generate random numbers, and it uses these numbers to select characters from a predefined character set. It then concatenates the selected characters to form a random string of 43 characters.\nYou can use a similar approach to generate a code verifier in other programming languages. Just make sure to use a CSPRNG to ensure that the code verifier is truly random and secure.\nOnce you have generated the code verifier, you will need to create a code_challenge from it. The code challenge is a hashed version of the code verifier that is sent to the authorization server in the authorization request. You can create the code challenge by running the code verifier through a SHA-256 hash function, and then base64-url encoding the result.\nTo create a code_challenge in JavaScript, you can use the crypto module to perform the SHA-256 hash and the btoa function to perform the base64-url encoding.\nHere\u0026rsquo;s an example of how you could create a code_challenge in JavaScript:\nconst crypto = require(\u0026#39;crypto\u0026#39;); function createCodeChallenge(codeVerifier) { // Perform SHA-256 hash of codeVerifier const hash = crypto.createHash(\u0026#39;sha256\u0026#39;); hash.update(codeVerifier); const codeChallenge = hash.digest(\u0026#39;base64\u0026#39;); // Base64-url encode the code challenge return codeChallenge.replace(/\\+/g, \u0026#39;-\u0026#39;).replace(/\\//g, \u0026#39;_\u0026#39;).replace(/=+$/, \u0026#39;\u0026#39;); } const codeVerifier = generateCodeVerifier(); const codeChallenge = createCodeChallenge(codeVerifier); Further readings PKCE is defined in 🔗RFC 7636 ","description":"Authorization Code Flow with Proof Key for Code Exchange The Authorization Code Flow with Proof Key for Code Exchange (PKCE) is an OAuth 2.0 flow that is used to secure the authorization process in native applications and single-page applications (SPAs). It is an extension to the standard authorization code flow, and it adds a step that helps to prevent authorization code interception attacks.\nA description of the authorization code flow with PKCE:"},{"id":31,"href":"/providers/","title":"Providers","parent":"Uitsmijter Documentation","content":" Providers General provider information User Login Provider User Validation Provider ","description":" Providers General provider information User Login Provider User Validation Provider "},{"id":32,"href":"/general/quickstart/","title":"Quick Start Guide","parent":"General","content":" Quick Start Guide for Kubernetes This guide covers all you need to get up and running with Uitsmijter. The documentation is based on a fictive Project for better understanding when and why to set some configurations.\nMeet the requirements This quick start guide assumes that the requirements are given. See this list of requirements that cover the following criteria:\nKubernetes is up and running Traefik is up and running Your cluster is able to get valid certificates for ingresses, e.g. with cert-manager Needed privileges to deploy onto your cluster To deploy a working instance of Uitsmijter you need to have privileges on the kubernetes cluster that allow you to deploy the following resource kinds:\nA service account with a cluster role is needed to allow Uitsmijter to read its CustomResources\nClusterRole ClusterRoleBinding ServiceAccount CustomResources definitions are needed to declare Tenants and Clients:\nCustomResourceDefinition Kubernetes Resources will be installed during the installation:\nNamespace ConfigMap Secret Service Deployment StatefulSet Ingress HorizontalPodAutoscaler The Interceptor-Mode is relying on Traefik Middlewares that will be set up during the installation:\nMiddleware CustomResources, declared by CustomResourceDefinition should be allowed to create, list and edit by your account in your namespaces:\nClient Tenant Make sure that you have these rights on your cluster (an admin certainly will have all of these). If not, please ask your system administrator for help.\nPrepare the installation Uitsmijter offers a 🔗 Helm installation routine. Download the Values.yaml first and change the values for your needs. The following example describes the sections on a fictive project. You have to change the values accordingly.\nThe Project Setup: We are planning a new customer portal for the domain example.com. The portal should be available for customers to send small notes to a selected group of recipients. However, we are planning to create different Microservices behind a Single-Page-Application (SPA).\nThe SPA shows general available content and offers a login button. Various functions are available only if a user is logged in. Without a valid login the user sees marketing project information provided by a cms. After login the user has access to its own profile, address book and incoming messages and also allowed to write a new message to all participants of the address book.\nThe business requirements say that certain users with the partner role should have an extra functionality that is available as a link to a portal that is made by another team. If the user is logged in to example.com then the user should also be logged in to the other portal located at partner.example.com.\nSo far so good. The architecture of the new project is set and looks like this:\nportal.example.com (portal.example.com) partner.example.com (partner.example.com) CMS (cms.example.com) Profile backend (profile.srv.example.com) Address book backend (contacts.srv.example.com) Inbox backend (inbox.srv.example.com) Send messages backend (send.srv.example.com) As you can see we do make the services public available! We will secure them later on with a JWT. To make it accessible from within the SPA it should be publicly available, otherwise we would need a 🔗 BFF.\nCreate a User Backend:\nSomewhere user data must be stored. Uitsmijter does not store any account data, profiles or passwords. To create a store for the users credentials either a service must be created or selected from the existing once. In our example the Profile backend would fit, but this we want to make public available and the user store should only be accessible within the cluster. So we could do an extra route that is only available from a private service but for the sake of security and the luck of a new project we create a service that is just there to store user credentials.\nThis new Credentials service got one route named: \u0026ldquo;POST: /validate-login\u0026rdquo; and fires a query against a database:\nSELECT `id`, `role`, `profile` FROM accounts WHERE `username` = ? AND `passwordhash` = ?; In our example passwords are stored as a sha256-Hash. You can choose between sha256, md5 and plain text.\nSome other applications will fill in the users after registration. This is out of scope for now. Important is that the /validate-login takes two parameters: username and passwordHash and returns a status 200 with a user profile object or some unauthorised error if the credentials do not match.\nIn case the credentials match, return the user profile object:\nHTTP/1.1 200 Content-Type: application/json; charset=UTF-8 { \u0026#34;id\u0026#34;: \u0026#34;${result.id}\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;${result.role}\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;${result.profile}\u0026#34;, } We host this little service in the usertrunk namespace with a service that points to the deployment:\n--- kind: Service apiVersion: v1 metadata: namespace: usertrunk name: checkcredentials spec: selector: app: userdb ports: - protocol: TCP port: 80 targetPort: 8080 It\u0026rsquo;s time to install Uitsmijter!: At this point in time, we need some service that handles the authorisation for our project. We do not want to log in multiple times to different portals, and we do not want to authenticate the user in all backends. Backends should be denied the access if a user request with an invalid token, and access data on the users behalf if the token is correct.\nThat implies that we expect some criteria:\nThe user must login to get a valid token The token must encode a unique subject to identify the user across all the backends The SPA must retrieve the token securely To allow other Portals (like partner.example.com) to join the SSO, authorisation must be outside the main portal Edit the Uitsmijter Values.yaml: In this section we go through all the available settings and describe them in detail with recommended settings for the demo project described above.\nNamespace namespaceOverride: \u0026#34;\u0026#34; This value specifies the namespace in which Uitsmijter should be installed. We recommend to install into the default namespace: uitsmijter. If you are planning installation into another namespace, you have to adjust Middleware paths later on. That is very easy if you know what you are doing, but can be confusing if you are new to Kubernetes or 🔗 Ingress middleware with Traefik. If you want to start without hassle and without debugging it is highly recommended to install Uitsmijter in the desired namespace first.\nRepository, Images and Tags image: repository: docker.ausdertechnik.de/uitsmijter/uitsmijter # Overrides the image tag whose default is the chart appVersion. tag: \u0026#34;\u0026#34; If you downloaded the newest version from the public repository the settings are just fine and work out of the box. Only if you host Docker images at a private repository you need to change the image.repository path to locate to your private copy of the image. For example: docker.example.com/sso/uitsmijter.\nWe do not recommend to host a single private copy of Uitsmijter in your own repository, because we are updating the images to fix bugs and improve features frequently. To get informed about updates and pull from the latest version you may want to clone a mirror of the whole repository instead. If you do not know how to do this, please ask for assistance.\nThe Version tag is set automatically according to the Application version of the Helm chart. Please be sure that you have downloaded the latest version. Only if you are doing an upgrade, you have to set the version by hand. For example upgrading from version 1.0.0 to version 1.0.1 you have to set the tag:\ntag: \u0026#34;1.0.1\u0026#34; Repository secrets imagePullSecrets: Default is blank, because Uitsmijter is public available. But if you are cloning the repository into your private one, it may be secured by a imagePullSecret. You can define the name of the secret here.\nBeware that the secret must be present in the namespace of Uitsmijter!\nExample:\nimagePullSecrets: - name: my-repository-pull-secret Global settings jwtSecret: \u0026#34;vosai0za6iex8AelahGemaeBooph6pah6Saezae0oojahfa7Re6leibeeshiu8ie\u0026#34; redisPassword: \u0026#34;Shohmaz1\u0026#34; storageClassName: default-ext4 installCRD: true installSA: true You have to change the values of the passwords in jwtSecret and redisPassword!\nThe jwtSecret is a global passphrase with which all JWTs are signed. Applications dealing with the JWT must know this shared secret. The jwtSecret should be set while installation and kept on the server only. We highly recommend to use 🔗 config-syncer to share the secret into other namespaces.\nFrom the example above we decided that the Profile backend, Address book backend, Inbox backend and Send messages backend will get their own namespaces to collect the backend and the databases, as well as services and ingresses all together in the domain of the service:\nprofile address inbox sender The jwtSecret will be created as a secret in the uitsmijter namespace (if not changed with namespaceOverride). All the backends need to know about the secret to validate the incoming JWT. Rather than creating handwritten secrets in all the four namespaces that can run out of sync can run out of sync while rolling the secret (that you should do from time to time), we recommend to sync the secret from the uitsmijter namespace into the profile, address, inbox and sendernamespace.\nTo sync the secret into namespaces add a label to the namespace the secret has to sync in:\n--- apiVersion: v1 kind: Namespace metadata: name: profiles labels: jwt-secret/sync: \u0026#34;true\u0026#34; jwt-secret/sync: \u0026quot;true\u0026quot; takes a look for the secret and syncs it into the namespace profiles. For more information please take a look at the 🔗 config-syncer documentation.\nThe Uitsmijter installation will set up a 🔗 Redis database to store refresh tokens. The redisPassword will only be used inside the uitsmijter namespace, and you have to replace the value while installing.\nAttention: after changing the redis password you have to roll out redis again and restart the services. We recommend to generate a random password at the first installation and keep it secret for the implementation. To roll the secret you may want to come back later and 🔗 read this article.\nThe storageClassName highly depends on your Kubernetes installation. You can list all available storage classes with kubectl:\nkubectl get sc Make sure that you choose a storage class that is available on all of your nodes. For more information read the documentation that 🔗 describes the concept of a StorageClass in Kubernetes.\nConfig section config: # Log format options: console|ndjson logFormat: \u0026#34;console\u0026#34; # Log level options: trace|info|error|critical logLevel: \u0026#34;info\u0026#34; cookieExpirationInDays: 7 tokenExpirationInHours: 2 tokenRefreshExpirationInHours: 720 logFormat: The log format can be switched between console and ndjson. console will print out each log entry on a single line with the level and the server time:\n[NOTICE] Wed, 21 Dec 2022 10:48:24 GMT: Server starting on http://127.0.0.1:8080 If you are using a log aggregator it is more familiar to log in 🔗 ndjson:\n{\u0026#34;function\u0026#34;:\u0026#34;start(address:)\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;NOTICE\u0026#34;,\u0026#34;date\u0026#34;:\u0026#34;2022-12-21T10:52:18Z\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Server starting on http:\\/\\/127.0.0.1:8080\u0026#34;} logLevel: The standard log level is info and provides a good overview of what Uitsmijter is doing. info also prints out notices, errors and critical alerts as well.\nIn case you want to see more of the applications behavior you may want to switch on the development trace logs. And if you just want to get alerts about things that do not go well, you can suppress most of the info and notices by setting the log level to error.\nEverything about logging is described in this separate section\ncookieExpirationInDays: You can adjust the days a cookie is valid without refreshing its value. A valid cookie means that the user is logged in. This is highly important for the Interceptor-Mode, because if you are deleting a user it can still use your service for the period of the cookie time! A good value to start with is 1 day. A deleted user is valid for the maximum of 24h in Interceptor-Mode and with maximum of tokenExpirationInHours for each OAuth-FLow.\nThe cookie expiration time has to be always equal or greater than the token expiration. In the example project we assume that a user pays in a monthly subscription, and we do not have external resources protected with interceptor yet. In this case 7 days is a very good starting point while development the services and will fit our needs later on, too.\ntokenExpirationInHours: In OAuth-FLow the user exchanges an authorization code (see grant_types) for an access and refresh token. If the access token expires, a new valid one can obtained with the refresh token.\nAs long as the access token is not expired, a user is logged in, even if the user has been deleted from the credentials service. In the example of 2 hours the user can access our portal at least for a maximum of 2 hours before being kicked out. This setting is regardless of the cookie lifetime.\nSpecial case silent login: If silent login is turned on, the login might happen automatically! You should only rely on the token expiration time when silent login is turned off (enabled by default). More information is provided in the tenant and client configuration section.\ntokenRefreshExpirationInHours: For every code exchange and every refresh the authorisation server generates a pair of an access token and a refresh token. The access token is a Bearer encoded JWT with the user profile encoded. The refresh token is a random key that can be used to refresh the access token. If an access token gets invalid, the user (mostly the library that is used) can get a new fresh valid access token with the refresh token (see grant_types).\nUitsmijter stores the refresh tokens for a defined amount of time. If a user has a valid and known refresh token, an access token can be requested.\nTherefor the refresh expiration period must be longer than the access token.\nDo you know those mobile Apps where you are always logged in after initial registration? Those apps know you because they have a very long refresh token period (sometimes ~1 year). When opening the app the first thing is to exchange the access token, regardless of the period, with the very long-lived refresh token. This is the way you are always signed in. In our example after 30 days (720 hours) of inactivity the user must log in with credentials again.\nOur recommendation for the first installation is set as defaults. You may want to adjust the settings later on to fit to your business model. If you need any assistance please to not hesitate to contact our consultants or ask the community.\nDomains Uitsmijter should run at least on one domain. At least, because Uitsmijter is multi tenant and multi client aware and one instance can run for more than one domain. For large installations with multiple different brands it may be a good idea to run one clustered Uitsmijter and provide the login functionality to different domains, so that a login does not change the main domain to ensure the trust level for your customers.\ndomains: - domain: \u0026#34;login.ham.test\u0026#34; tlsSecretName: \u0026#34;ham.test\u0026#34; - domain: \u0026#34;id.example.com\u0026#34; tlsSecretName: \u0026#34;example.com\u0026#34; In the example above, Uitsmijter is available at login.ham.test and also at id.example.com. Both domains point to the same instance.\nFor both of our example portals we just need one domain:\ndomains: - domain: \u0026#34;id.example.com\u0026#34; tlsSecretName: \u0026#34;example.com\u0026#34; Replicas Uitsmijter supports 🔗 Horizontal Pod Autoscaling well. For more details please take a look at hpa.yaml inside the helm templates.\nYou can set the minimum and maximum amount of replicas in the hpa.yaml. The default is set to minReplicas: 1 and maxReplicas: 3.\nCongratulations, the hard part is done. You have configured your Uitsmijter installation successfully. Most of the values should be the same as given in defaults, that is ok, you can revisit and fine tune the server later on.\nInstall Uitsmijter onto your cluster To install Uitsmijter onto your cluster a Helm Chart is provided. If you have access to the cluster and check the privileges mentioned above, the following steps install everything right in place.\nhelm repo add uitsmijter https://charts.uitsmijter.io/ helm update helm install uitsmijter uitsmijter/uitsmijter Read more about the helm charts configuration.\nAfter installation make sure that your user has the rights to edit Clients and Tenants at least in your namespaces.\nCreate the first Tenant In the project example we are setting up Uitsmijter for one domain and one company. Only one tenant is needed. Examples for a multi-tenant setup is given in the tenant and client configuration section. Our one and only tenant is called portal. For the configuration of this tenant we first create a new namespace to collect all overall settings there:\nkubectl create ns portal In that namespace we will add the tenant. Therefore, we have to define it first:\n--- apiVersion: \u0026#34;uitsmijter.io/v1\u0026#34; kind: Tenant metadata: name: portal spec: hosts: - portal.example.com - partner.example.com interceptor: enabled: false domain: login.example.com cookie: .example.com providers: - | class UserLoginProvider { constructor(credentials) { commit(true); } get canLogin() { return true; } get userProfile() { return {message:\u0026#34;DO NOT USE THIS IN PRODUCTION\u0026#34;}; } get role() { return \u0026#34;development\u0026#34;; } } - | class UserValidationProvider { constructor(args) { commit(true); } isValid() { return true; } } Save the file to portal-tenant.yaml.\nImportant for HPA: Change the ident with a new generated uuid and keep it consistent along the tenant name. You can learn everything about tenants in tenant and client configuration section.\nTo get started quickly we have to care about the providers only. The script above is just a working example that logs in every user with every password. That is not what we want. We have created a credentials service above that checks the user credentials in a database and returns a profile if found. The service takes an username and a hashed passwordinput.\nYou can learn everything about Providers on the General provider information page and explicit about the UserLoginProvider on the User Login Provider page.\nThe described Credentials service provides a route \u0026ldquo;POST: /validate-login\u0026rdquo; and is accessible within the cluster only. We host the service checkcredentials in the namespace usertrunk. It is internally available at: checkcredentials.usertrunk.svc.cluster.local. The service expects a sha265 hashed password, because we do not send cleartext passwords to other services! The provider scripts should look like this:\nclass UserLoginProvider { isLoggedIn = false; profile = {}; role = null; constructor(credentials) { fetch(`http://checkcredentials.usertrunk.svc.cluster.local/validate-login`, { method: \u0026#34;post\u0026#34;, body: { username: credentials.username, passwordHash: sha256(credentials.password) } }).then((result) =\u0026gt; { var subject = {}; profile = JSON.parse(result.body); if (result.code == 200) { this.isLoggedIn = true; this.role = profile.role; subject = {subject: profile.userId}; } commit(result.code, subject); } ); } get canLogin() { return this.isLoggedIn; } get userProfile() { return this.profile; } get role() { return this.role; } } class UserValidationProvider { isValid = false; constructor(args) { fetch(`http://checkcredentials.usertrunk.svc.cluster.local/validate-user`, { method: \u0026#34;post\u0026#34;, body: { username: args.username, } }).then((result) =\u0026gt; { var subject = {}; profile = JSON.parse(result.body); if (result.code == 200) { this.isValid = true; } commit(this.isValid); } ); } get isValid() { return this.isValid; } } Update the script in ll-tenant.yaml.\nThe script will send the users username and a sha265 hashed password to checkcredentials.usertrunk.svc.cluster.local/validate-login and if this endpoint responses successfully the script prepares the class variables that are consumed by the auth server later in the auth process.\nThat\u0026rsquo;s it. Your first secure tenant is set up and connected to your users service.\nApply the tenant to the namespace we have created above:\nkubectl apply -n portal portal-tenant.yaml Create a client To connect an OAuth client with Uitsmijter we also have to define a client. A tenant can have multiple clients (e.g. for an SPA and an App). The client defines what OAuth-Flows are allowed and what scopes a user can have if asked for.\nHere is an example client for our SPA at portal.portal.com:\n--- apiVersion: \u0026#34;uitsmijter.io/v1\u0026#34; kind: Client metadata: name: example-portal spec: ident: 540FF520-2BDF-4C6F-9D9F-DC88A9DB41F6 tenantname: portal/portal redirect_urls: - https://portal.example.com/.* grant_types: - authorization_code - refresh_token scopes: - access - profile::read - profile::write - addressbook:read - addressbook:write - addressbook:delete - inbox:read - inbox:delete - sendmessages referrers: - https://.*.example.com/.* isPkceOnly: true The tenant name must match and the uuid ident must be unique in the Uitsmijter universe on your cluster. We only allow clients that are connected from the referrers: https://..example.com/., that includes all subdomains of example.com and login can happen from any path of that domains. This makes it possible to request a login even from a landing page like specialoffers.example.com, but the redirect is allowed to https://portal.example.com/.* only. So after login the user will be redirected to our portal.\nThis does not work for the partner portal. Either we create a new client for that, or we expand the redirect_urls array\nredirect_urls: - https://portal.example.com/.* - https://partner.example.com/.* But because the partner portal is made by another team, we recommend to add a second client. To learn all about the client settings please take a look at the tenant and client configuration section.\nChecking the Uitsmijter configuration Uitsmijter automatically reloads changed tenants and clients. Take a look at the logs to see if the tenant and client is loaded without errors:\nkubectl logs -n uitsmijter -l app=uitsmijter -l component=authserver You should see something similar to these lines:\nFount 1 items in TenantList/uitsmijter.io/v1 Found tenant in crd: example-portal from namespace: portal Load tenant from crd: example-portal successfully Added new tenant \u0026#39;example-portal\u0026#39; [EDB1B825-CFED-41F0-A844-682D7B695B72] with 1 hosts and the client\nFount 5 items in ClientList/uitsmijter.io/v1 Found client in crd: example-portal from namespace: portal Load client from crd: example-portal Added new client \u0026#39;example-portal\u0026#39; [540FF520-2BDF-4C6F-9D9F-DC88A9DB41F6] for tenant \u0026#39;portal\u0026#39; Congratulations!! All is set up, and you can build your portal with an OAuth login flow. If you aren\u0026rsquo;t familiar with Single page OAuth flows, we have prepared a little demo application at spa.littleletter.de. The sourcecode is available. Please ask for any assistance.\nFurther readings Walkthrough guide for securing static webserver resources Migrating a monolith application into microservices with single sign on ","description":"Quick Start Guide for Kubernetes This guide covers all you need to get up and running with Uitsmijter. The documentation is based on a fictive Project for better understanding when and why to set some configurations.\nMeet the requirements This quick start guide assumes that the requirements are given. See this list of requirements that cover the following criteria:\nKubernetes is up and running Traefik is up and running Your cluster is able to get valid certificates for ingresses, e."},{"id":33,"href":"/customisation/","title":"Customisation","parent":"Uitsmijter Documentation","content":" Customisation Login Template ","description":" Customisation Login Template "},{"id":34,"href":"/contribution/faq/","title":"Frequently Asked Questions","parent":"Contribution","content":" Why there is no Admin-Interface for Uitsmijter? Adding an admin UI to the server software can have its drawbacks and may not be the best approach for the following reasons:\nThere should be one way to do it (see Project Goals: Introducing an admin UI means providing one other way to configure and manage the server software that is hard to sync back to descriptive files in Kubernetes. This can limit flexibility and customization options for users who prefer different tools for editing configuration files. By sticking solely to YAML configuration files, users can leverage their preferred text editors, version control systems, and automation tools, allowing for greater flexibility and compatibility with existing workflows. YAML configuration files provide a well-established and widely adopted method for configuring server software. They are human-readable, versionable, and easy to share, making them a popular choice for many server administrators. Adding an admin UI alongside configuration files may introduce confusion and complexity by having multiple ways to configure the software, potentially leading to configuration inconsistencies and conflicts. Developing and maintaining an admin UI requires additional effort and resources. It involves designing and implementing a user-friendly interface, handling user input validation, managing UI-specific issues, and keeping the UI in sync with any changes or updates to the underlying server software. This added complexity can increase development and maintenance overhead. This is subtracted from the time spent working on an understandable and easy to use descriptive setting. Server administrators are typically comfortable working with the command line and text-based interfaces. They are accustomed to configuring and managing server software through the console and may prefer the flexibility and efficiency it offers. Introducing an admin UI may not align with the preferences and expectations of the target audience, potentially resulting in a less intuitive or less efficient user experience. Web-based admin interfaces introduce additional security risks, such as potential vulnerabilities in the UI framework, the need for proper authentication and authorization mechanisms, and the potential for cross-site scripting (XSS) or other web-related attacks. By avoiding an admin UI, you can minimize the attack surface and reduce the potential for security breaches associated with web-based interfaces. An admin UI is the entry to hiding complexity behind shiny buttons and checkboxes. We do not want to hide complexity, we want to avid it at the first place. This explains why Uitsmijter does not and will never have an administrative interface.\n","description":"Why there is no Admin-Interface for Uitsmijter? Adding an admin UI to the server software can have its drawbacks and may not be the best approach for the following reasons:\nThere should be one way to do it (see Project Goals: Introducing an admin UI means providing one other way to configure and manage the server software that is hard to sync back to descriptive files in Kubernetes. This can limit flexibility and customization options for users who prefer different tools for editing configuration files."},{"id":35,"href":"/contribution/certificate_of_origin/","title":"Developer Certificate of Origin","parent":"Contribution","content":" Developer Certificate of Origin Version 1.1\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\nEveryone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.\nDeveloper\u0026rsquo;s Certificate of Origin 1.1\nBy making a contribution to this project, I certify that:\n(a) The contribution was created in whole or in part by me and I have the right to submit it under the open source license indicated in the file; or\n(b) The contribution is based upon previous work that, to the best of my knowledge, is covered under an appropriate open source license and I have the right under that license to submit that work with modifications, whether created in whole or in part by me, under the same open source license (unless I am permitted to submit under a different license), as indicated in the file; or\n(c) The contribution was provided directly to me by some other person who certified (a), (b) or (c) and I have not modified it.\n(d) I understand and agree that this project and the contribution are public and that a record of the contribution (including all personal information I submit with it, including my sign-off) is maintained indefinitely and may be redistributed consistent with this project or the open source license(s) involved.\n","description":"Developer Certificate of Origin Version 1.1\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\nEveryone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.\nDeveloper\u0026rsquo;s Certificate of Origin 1.1\nBy making a contribution to this project, I certify that:\n(a) The contribution was created in whole or in part by me and I have the right to submit it under the open source license indicated in the file; or"},{"id":36,"href":"/versions/","title":"Versions","parent":"Uitsmijter Documentation","content":" Versions Enterprise Edition ","description":" Versions Enterprise Edition "},{"id":37,"href":"/contribution/codeofconduct/","title":"Code of Conduct","parent":"Contribution","content":" Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\nOur Standards Examples of behavior that contributes to creating a positive environment include:\nUsing welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the project, the team and the users. Showing empathy towards other team members Examples of unacceptable behavior by participants include:\nThe use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others\u0026rsquo; private information, such as a physical or electronic address, without explicit permission. Keep the user data safe! Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\nScope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its team community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\nEnforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at abuse@uitsmijter.io. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project\u0026rsquo;s leadership.\n","description":"Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\nOur Standards Examples of behavior that contributes to creating a positive environment include:"},{"id":38,"href":"/contribution/","title":"Contribution","parent":"Uitsmijter Documentation","content":" Contribution And Development Project information Provided toolchain to work with the codebase Development Guidelines Overall Goals Frequently Asked Questions Developer Certificate of Origin Code Of Conduct List of used 3rd Party Tools Links Official Uitsmijter website Github Organisation page Connect with us on our Mastodon instance Uitsmijter Discourse forum ","description":" Contribution And Development Project information Provided toolchain to work with the codebase Development Guidelines Overall Goals Frequently Asked Questions Developer Certificate of Origin Code Of Conduct List of used 3rd Party Tools Links Official Uitsmijter website Github Organisation page Connect with us on our Mastodon instance Uitsmijter Discourse forum "},{"id":39,"href":"/contribution/3rdparty/","title":"3rd Party Tools","parent":"Contribution","content":" 3rd Party tools used in Uitsmijter https://github.com/Olipro/Coverify Convert LLVM code coverage to cobertura https://vapor.codes Server Framework we love and used for this project https://github.com/swift-server-community/SwiftPrometheus.git Prometheus exporter for custom metrics https://github.com/jectivex/JXKit Inspiration for the JavaScript bridge to work on linux https://github.com/krzyzanowskim/CryptoSwift.git Crypto related functions and helpers for Swift https://github.com/jpsim/Yams.git A sweet and swifty YAML parser built on LibYAML. https://github.com/swiftkube/client Inspiration for a Swift client for talking to a Kubernetes cluster Graphs in this wiki are build with ASCIIFlow.\nYou can find a list of allowed licenses under https://github.com/cncf/foundation/blob/main/allowed-third-party-license-policy.md\n","description":"3rd Party tools used in Uitsmijter https://github.com/Olipro/Coverify Convert LLVM code coverage to cobertura https://vapor.codes Server Framework we love and used for this project https://github.com/swift-server-community/SwiftPrometheus.git Prometheus exporter for custom metrics https://github.com/jectivex/JXKit Inspiration for the JavaScript bridge to work on linux https://github.com/krzyzanowskim/CryptoSwift.git Crypto related functions and helpers for Swift https://github.com/jpsim/Yams.git A sweet and swifty YAML parser built on LibYAML. https://github.com/swiftkube/client Inspiration for a Swift client for talking to a Kubernetes cluster Graphs in this wiki are build with ASCIIFlow."},{"id":40,"href":"/resources/","title":"Resources","parent":"Uitsmijter Documentation","content":"","description":""},{"id":41,"href":"/licence/","title":"License","parent":"Uitsmijter Documentation","content":" Apache License _Version 2.0, January 2004:\nhttp://www.apache.org/licenses/\nTERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\nDefinitions.\n\u0026ldquo;License\u0026rdquo; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.\n\u0026ldquo;Licensor\u0026rdquo; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.\n\u0026ldquo;Legal Entity\u0026rdquo; shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u0026ldquo;control\u0026rdquo; means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.\n\u0026ldquo;You\u0026rdquo; (or \u0026ldquo;Your\u0026rdquo;) shall mean an individual or Legal Entity exercising permissions granted by this License.\n\u0026ldquo;Source\u0026rdquo; form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.\n\u0026ldquo;Object\u0026rdquo; form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.\n\u0026ldquo;Work\u0026rdquo; shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).\n\u0026ldquo;Derivative Works\u0026rdquo; shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.\n\u0026ldquo;Contribution\u0026rdquo; shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u0026ldquo;submitted\u0026rdquo; means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u0026ldquo;Not a Contribution.\u0026rdquo;\n\u0026ldquo;Contributor\u0026rdquo; shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.\nGrant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.\nGrant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.\nRedistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:\n(a) You must give any other recipients of the Work or Derivative Works a copy of this License; and\n(b) You must cause any modified files to carry prominent notices stating that You changed the files; and\n(c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and\n(d) If the Work includes a \u0026ldquo;NOTICE\u0026rdquo; text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.\nYou may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.\nSubmission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.\nTrademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.\nDisclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u0026ldquo;AS IS\u0026rdquo; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.\nLimitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.\nAccepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.\nEND OF TERMS AND CONDITIONS\nCopyright 2023, aus der Technik Simon \u0026amp; Sinon GbR\n","description":"Apache License _Version 2.0, January 2004:\nhttp://www.apache.org/licenses/\nTERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\nDefinitions.\n\u0026ldquo;License\u0026rdquo; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.\n\u0026ldquo;Licensor\u0026rdquo; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.\n\u0026ldquo;Legal Entity\u0026rdquo; shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity."},{"id":42,"href":"/_sidebar/","title":"Sidebar","parent":"Uitsmijter Documentation","content":" Uitsmijter Visit the home of the documentation.\nGeneral About Terminology Motivation Requirements Quick Start Guide Configuration Entities Tenant and client configuration Logging OAuth2 Server OAuth flow Grant types Available Endpoints JWT Decoding Authorization Code Flow with Proof Key for Code Exchange Interceptor Walkthrough Guide Interceptor Mode Example Deployment Migrating a monolith application Providers General provider information User Login Provider Customisation Login Page Development How to start development is covered in the development information section.\nDevelopment Guidelines Code Of Conduct Used 3rd Party Tools ","description":"Uitsmijter Visit the home of the documentation.\nGeneral About Terminology Motivation Requirements Quick Start Guide Configuration Entities Tenant and client configuration Logging OAuth2 Server OAuth flow Grant types Available Endpoints JWT Decoding Authorization Code Flow with Proof Key for Code Exchange Interceptor Walkthrough Guide Interceptor Mode Example Deployment Migrating a monolith application Providers General provider information User Login Provider Customisation Login Page Development How to start development is covered in the development information section."},{"id":43,"href":"/resources/demopage/","title":"Index","parent":"Resources","content":" Demo Deployment Files namespace tenant client content service ingress-open ingress-secured pod ","description":" Demo Deployment Files namespace tenant client content service ingress-open ingress-secured pod "},{"id":44,"href":"/general/ingredients/","title":"Ingredients","parent":"General","content":" Ingredients for an Uitsmijter 1 teaspoon butter 2 large eggs 2 slices white bread 2 slices shaved boiled ham 2 large slices aged Gouda cheese Salt and Pepper First melt the butter in a frying pan or skillet and fry the eggs. Once the bottoms of the eggs are set, take the pan off the heat, place a lid on the pan and allow the eggs to steam until the top has firmed up. If you prefer your eggs more thoroughly cooked, flip them over and fry until the yolk is done to your liking.\nLightly toast the bread and place the slices of toast on a plate. Top the toast with ham and cheese and put the fried eggs on top of it.\nSeason to taste with salt and pepper.\n","description":"Ingredients for an Uitsmijter 1 teaspoon butter 2 large eggs 2 slices white bread 2 slices shaved boiled ham 2 large slices aged Gouda cheese Salt and Pepper First melt the butter in a frying pan or skillet and fry the eggs. Once the bottoms of the eggs are set, take the pan off the heat, place a lid on the pan and allow the eggs to steam until the top has firmed up."},{"id":45,"href":"/contribution/list-of-competitors/","title":"List Of Competitors","parent":"Contribution","content":" List Of Competitors We maintain a list of competitors. If your product is not included in this list, feel free to add it.\nName Link Licence Cost Github-Stars Relevant Features Keycloak https://www.keycloak.org/ Apache-2.0 0 16.6k ✓ Azure Active Directory https://azure.microsoft.com Proprietär ab $ 599,-/Monat ‒ SaaS OneLogin https://www.onelogin.com/de-de/ Proprietär ? ✓ Auth0 https://auth0.com Proprietär ab $ 800,-/Monat ✓ SaaS Ping Identity https://www.pingidentity.com/de.html Proprietär ? ‒ WSO2 Identity Server https://wso2.com/identity-server/ Proprietär ? ‒ ForgeRock https://www.forgerock.com/ Proprietär ? ‒ OpenAM https://github.com/ForgeRock/openam-community-edition 0 117 ‒ FusionAuth https://fusionauth.io/ Proprietär ab $ 125,-/Monat ✓ Okta Workforce Identity https://www.okta.com/de/workforce-identity/ Proprietär ? ‒ Casdoor https://github.com/casdoor/casdoor Apache-2.0 0 6.5k ‒ Authelia https://github.com/authelia/authelia Apache-2.0 0 16.7k ‒ ZITADEL https://github.com/zitadel/zitadel Apache-2.0 0 3.9k ‒ IdentityServer https://duendesoftware.com/ Proprietär ‒ Ory https://www.ory.sh/ Proprietär ‒ ory/hydra https://github.com/ory/hydra Apache-2.0 0 14.2k ‒ ory/kratos https://github.com/ory/kratos Apache-2.0 0 8.9k ‒ Atricore https://iam.tf/ ‒ Authentik https://github.com/goauthentik/authentik https://github.com/goauthentik/authentik/blob/main/LICENSE 0 4.1k ‒ Authing https://github.com/Authing/Authing MIT 0 975 ‒ Airlock https://www.airlock.com/ Proprietär ‒ cerbos https://github.com/cerbos/cerbos Apache-2.0 0 1.5k ‒ dex https://github.com/dexidp/dex Apache-2.0 0 8.2k ‒ openfga https://github.com/openfga/openfga Apache-2.0 0 1.2k ‒ topaz https://github.com/aserto-dev/topaz Apache-2.0 0 678 ‒ ","description":"List Of Competitors We maintain a list of competitors. If your product is not included in this list, feel free to add it.\nName Link Licence Cost Github-Stars Relevant Features Keycloak https://www.keycloak.org/ Apache-2.0 0 16.6k ✓ Azure Active Directory https://azure.microsoft.com Proprietär ab $ 599,-/Monat ‒ SaaS OneLogin https://www.onelogin.com/de-de/ Proprietär ? ✓ Auth0 https://auth0.com Proprietär ab $ 800,-/Monat ✓ SaaS Ping Identity https://www.pingidentity.com/de.html Proprietär ? ‒ WSO2 Identity Server https://wso2.com/identity-server/ Proprietär ?"},{"id":46,"href":"/tags/","title":"Tags","parent":"Uitsmijter Documentation","content":"","description":""},{"id":47,"href":"/home/","title":"Uitsmijter","parent":"Uitsmijter Documentation","content":" Uitsmijter Documentation A versatile OAuth2 authorization server and Traefik middleware for Kubernetes and Docker. Uses your existing user-database to prevent vendor lock-in.\nAbout Uitsmijter is a standalone OAuth2 authorization server with embedded middleware that provides login mechanisms to your project without changing the existing user database.\nThe goal of this project is to bring trustworthy and easy-to-integrate security to your project, within a few hours from installation, configuration and implementation to go-live.\nMain goals of the project:\nEasy migration Move from a single application login to a distributed OAuth 2 flow for many kinds of applications in just one day Fast implementation Reliability OAuth 2 compatibility Fast response times Low Memory and CPU consumption Read more about Uitsmijter\nGetting familiar with the terminology used in this documentation\nNaming Uitsmijter is a popular breakfast, brunch and lunch dish in the Netherlands. The ingredients are put on top of each other, finishing with a fried egg on top that covers the ham and the cheese.\nLegend goes that this dish used to be served late at night, just before the guests are kicked out at closing time, which may explain why the Dutch name for this dish, \u0026ldquo;uitsmijter,\u0026rdquo; means \u0026ldquo;bouncer\u0026rdquo; or \u0026ldquo;doorman\u0026rdquo; in english.\nWe found this is an excellent name for the product, because it is put on top of your existing products (the ham and the cheese) and makes everything more delicious. The english translation bouncer makes perfect sense, because the applications inside no longer have to worry about their security. The bouncer will keep uninvited guests outside.\nMotivation We have treated it as normal that migration projects take a long time and involve a lot of risk. Uitsmijter hits a pretty crowded market of authorisation servers, but fills the need that migrations from a monolith into a microservice architecture should be nice and comfortable.\nWith Uitsmijter it is no longer a hurdle to implement secure and modern authentication methods. The product supports the developers in every project phase. It is such a pleasure to work with Uitsmijter that it makes sense to build new projects upon it, because the flexibility that is needed for smooth migrations are the successors of new ideas.\nYou may want to read the full motivation page to get a deeper understanding of why we are building Uitsmijter from the ground up.\nGetting started Requirements This application is meant to run on Kubernetes (K8s) and protects resources that run on Kubernetes clusters. Uitsmijter is tested on Kubernetes version 1.22.0 and above.\nThe Interceptor Mode is coupled to a preexisting 🔗 Traefik instance running on the cluster. Other ingress controllers are in planning, but still under development.\nYou can run Uitsmijter in a Docker environment with a 🔗 Traefik Endpoint or standaloone, but this is not covered in this documentation yet.\nRead the list of requirements, including links to set up those on your server.\nQuick start guide The description in the Quick Start Guide sets up Uitsmijter in a couple of minutes. There is also a walkthrough guide for the interceptor mode, that explains how to protect static websites.\nArchitecture Uitsmijter works on the basis of Tenants and Clients where Tenants are the top entity (for example internal users, users of a product etc.). They implement the access to an existing authentification backend via an authentication provider implemenation. Each Tenant has Clients (for example a Website, a mobile app and the web shop). The Clients can connected using different methods to Uitsmijter, depending what they need. Uitsmijter provides two main authentification mechanisms:\nThe Interceptor mode which authenticates every request to a page (for example of a single page application) and redirects the user to a login page when he is not logged in.\nAn OAuth 2 server which allows an application to be easily integrated via the OAuth 2 standard, normally used for bigger applications and mobile apps.\nInterceptor When a resource is requested, the middleware checks if the current user is logged in. If not, the request is redirected to the login page. If the user making the request is logged in, the middleware directs the request to the requested resource with an authorization header. The authorization header includes a Bearer token with an JWT encoded user profile.\nThe interceptor mode ist an excellent choose for:\nProtecting static websites Protecting landing pages Migrating legacy monolith applications Read the walkthrough guide for securing static webserver resources to see how to protect a static resource server in a couple of minutes. More example deployment may give you a complete picture about the mode and how to configure it for your needs. If you are migrating an existing project with its own user database to Uitsmijter, you may want to read a longer article about the migration a monolith application.\nAn in depth documentation can be found in the Interceptor Mode section.\nOAuth 2 Server OAuth 2 is a protocol that allows a user to authorize a third-party application or service to access their data or perform actions on their behalf on another web service. It streamlines the process of granting this authorization, making it more secure and convenient for users.\nOAuth 2 is well-suited for authenticating a user on a single page application or mobile app.\nIf you are new to OAuth, this overview of the OAuth flow will help you to understand the basic concept.\nUitsmijter supports various Grant types:\nAuthorization Code Refresh Token Password To set up the client library you find detailed information about the available endpoints on the dedicated page. Uitsmijter uses the default endpoints described in 🔗RFC 6749 but some libraries does not play well with the standards and needs information about the endpoint name. You can find all the necessary information on the available endpoints page.\nYou can decode the JWT on your own with a client library, or you may want to use the info-endpoint that uitsmijter supports.\nThe purpose of Proof Key for Code Exchange is to prevent attacks where an attacker might intercept the authorization code and use it to obtain an access token. It does this by introducing a \u0026ldquo;code verifier\u0026rdquo; and a \u0026ldquo;code challenge\u0026rdquo; that are sent to the authorization server during the authorization request. The authorization server uses the code challenge to verify that the authorization code was issued to the same client that is making the token request. This helps to prevent an attacker from being able to exchange the authorization code for an access token.\nProviders Providers are glue code between Uitsmijter and external resources, like your own user data store. Providers are very easy code written in plain ECMA-Script (Javascript). Even if you are not familiar with JavaScript, writing a provider is easy and straight forward.\nRead the general provider information before digging into the User Login Provider.\nConfiguration Tenants and Clients are described in the entities configuration section. For general configuration about Uitsmijter, please take a look at the quick start guide. To give a better overview the helm configuration page lists all available configuration parameters from the installation process, again.\nThe relation between tenants and clients are described in the Tenant and client configuration along examples and best practises.\nThe available log levels and formats are explained on the logging page.\nCustomisation Easy customisation is one of the main benefits of Uitsmijter. The authorisation server uses your user database through the ability of defining provider scripts. The Tenant and client configuration give you a tool to describing your needs to handle all logins to multiple projects with multiple devices with different access levels.\nThe customisation of login templates is possible by using template files or by defining an S3 bucket as a source.\nContribution And Development Uitsmijter is written in Swift 5.7. Please read the Development information and get familiar with the toolchain.\nWhen you fix a bug, or add a new feature, you have to commit it back to the community. Please read the development Guidelines first To make sure that you meet the requirements and that your change can be transferred to an official release without any problems. The guidelines are there to motivate. We do not want to disappoint any developer.\nOur Code Of Conduct is a vital asset for working together. Please do not oversee it!\nFinally, here is a list of used 3rd party tools that is used by uitsmijter. Thanks to all of them for the great work without Uitsmijter won\u0026rsquo;t be alive.\nLicence Uitsmijter is released under the Apache Licence 2.0.\n","description":"Uitsmijter Documentation A versatile OAuth2 authorization server and Traefik middleware for Kubernetes and Docker. Uses your existing user-database to prevent vendor lock-in.\nAbout Uitsmijter is a standalone OAuth2 authorization server with embedded middleware that provides login mechanisms to your project without changing the existing user database.\nThe goal of this project is to bring trustworthy and easy-to-integrate security to your project, within a few hours from installation, configuration and implementation to go-live."},{"id":48,"href":"/","title":"Uitsmijter Documentation","parent":"","content":"","description":""}]